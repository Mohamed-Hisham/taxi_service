<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.comment="Taxi reservation system modelling" org.eventb.core.configuration="org.eventb.core.fwd;de.prob.units.mchBase" org.eventb.texttools.text_lastmodified="1387072071827" org.eventb.texttools.text_representation="machine TaxiMachine // Taxi reservation system modelling&#10; sees Taxi_Context&#10;&#10;variables registered_taxis // set containing all the taxis registered in the system&#10;          busy_taxis // set containg all the occupied (hired) taxis&#10;          penalized_taxis // set containing all the penalized taxis&#10;          bookings // set of all the booking on the system&#10;          accepted_bookings // set of all accpeted bookings&#10;          declined_bookings // set of all declined bookings&#10;          booking_customer // a function relating a booking with its customer&#10;          booking_status // a function relating a booking with its status&#10;          booking_priority // a function relating a booking with its priority&#10;          booking_response // a function relating a booking with the response type it got&#10;          waiting_list // a function relating the bookings of the customer put on waiting list&#10;          reduced_threshold // Global variable for reduced responses threshold&#10;          nonallocation_threshold // Global variable for non-allocated responses threshold&#10;          reduced_warnings // set of reduced responses warnings issued by the system&#10;          nonallocation_warnings // set of non allocated responses warnings issued by the system&#10;          booking_taxi // a function relating a booking with a taxi&#10;          booking_number_of_passengers // a function relating a booking with the number of passengers required for it&#10;          taxi_capability // function between a taxi and capabilities offered&#10;          booking_capability // function between a booking and capabilities needed&#10;          nearby_taxis_pool // Set of taxis nearby the customer&#10;          bookings_queue // Queue for the bookings&#10;          bookings_pointer // Pointer for the bookings queue&#10;          driver_declined // boolean variable to check if the driver has declined or not&#10;&#10;invariants&#10;  @inv1 registered_taxis ⊆ TAXI // registered_taxis will be of type TAXI carrier set&#10;  @inv2 busy_taxis ⊆ TAXI // busy_taxis will be of type TAXI carrier set&#10;  @inv3 penalized_taxis ⊆ TAXI // penalized_taxis will be of type TAXI carrier set&#10;  @inv4 bookings ⊆ BOOKING // bookings will be of type BOOKING carrier set&#10;  @inv5 accepted_bookings ⊆ BOOKING // accepted_bookings will be of type BOOKING carrier set&#10;  @inv6 declined_bookings ⊆ BOOKING // declined_bookings will be of type BOOKING carrier set&#10;  @inv7 booking_customer ∈ BOOKING ⇸ CUSTOMER // Many to one relation between a booking and its customer&#10;  @inv8 booking_status ∈ BOOKING ⤔ STATUS // One to one relation between a booking and its status (open (default), coming, picked, delivered)&#10;  @inv9 booking_priority ∈ BOOKING ⤔ PRIORITY // One to one relation between a booking and its priority (high, normal)&#10;  @inv30 booking_response ∈ BOOKING ⤔ RESPONSE_TYPE // One to one relation between a booking and its response type (full, reduced)&#10;  @inv11 booking_taxi ∈ BOOKING ⤔ registered_taxis // One to one relation between a booking and the taxi allocated for it&#10;  @inv31 booking_number_of_passengers ∈ BOOKING ⤔ (1‥5) // One to one relation between a booking and the range of number of passengers from 1 to 5&#10;  @inv13 waiting_list ∈ accepted_bookings ⇸ CUSTOMER // Many to one relation between a booking and its customer being stored on the waiting list&#10;  @inv14 reduced_threshold ∈ (0‥100) // reduced responses threshold from 0..100&#10;  @inv15 nonallocation_threshold ∈ (0‥100) // non allocated responses threshold from 0..100&#10;  @inv16 reduced_warnings ⊆ WARNING // reduced_warnings set of type WARNING&#10;  @inv17 nonallocation_warnings ⊆ WARNING // nonallocation_warnings set of type WARNING&#10;  @inv18 taxi_capability ∈ registered_taxis ↔ CAPABILITY // function between the taxi and its capabilities offered&#10;  @inv19 booking_capability ∈ bookings ↔ CAPABILITY // function between the booking and its capabilities needed&#10;  @inv20 nearby_taxis_pool ⊆ registered_taxis // nearby taxis must be registered with the system&#10;  @inv21 bookings_queue ⊆ bookings // bookings in the queue must have BOOKING type&#10;  @inv22 bookings_pointer ∈ bookings_queue ↣ ℕ1 // relating the pointer of the booking queue to have range of positive numbers&#10;  @inv23 finite(ran(bookings_pointer)) // finite constraint to use the max function must have a known size&#10;  @inv24 finite(booking_response) // finite constraint to use the card function must have a known size&#10;  @inv25 driver_declined ∈ ℕ // Boolean value to check if the driver has declined 0=NO &amp; 1=YES&#10;&#10;events&#10;  event INITIALISATION // initialising all the set variables and thresholds to their initial values&#10;    then&#10;      @act1 registered_taxis ≔ ∅&#10;      @act2 busy_taxis ≔ ∅&#10;      @act3 penalized_taxis ≔ ∅&#10;      @act4 bookings ≔ ∅&#10;      @act5 accepted_bookings ≔ ∅&#10;      @act6 declined_bookings ≔ ∅&#10;      @act7 booking_customer ≔ ∅&#10;      @act8 booking_status ≔ ∅&#10;      @act9 booking_priority ≔ ∅&#10;      @act10 booking_response ≔  ∅&#10;      @act11 booking_taxi ≔ ∅&#10;      @act12 booking_number_of_passengers ≔ ∅&#10;      @act13 waiting_list ≔ ∅&#10;      @act14 reduced_warnings ≔ ∅&#10;      @act15 nonallocation_warnings ≔ ∅&#10;      @act16 nonallocation_threshold ≔ 5 // Assuming the maximum number before a non allocation warning is produced&#10;      @act17 reduced_threshold ≔ 5 // Assuming the maximum number before a reduced warning is produced&#10;      @act18 taxi_capability ≔ ∅&#10;      @act19 booking_capability ≔ ∅&#10;      @act20 bookings_pointer ≔ ∅&#10;      @act21 bookings_queue ≔  ∅&#10;      @act22 driver_declined ≔ 0 // Assuming the the driver is willing to accept and did not decline yet by default&#10;      @act23 nearby_taxis_pool ≔ ∅&#10;  end&#10;&#10;  event RegisterTaxi // This event registers a taxi with the system&#10;    any taxi capabilities_offered&#10;    where&#10;      @grd1 taxi ∈ TAXI // taxi is of type TAXI carrier set&#10;      @grd2 taxi ∉ registered_taxis // taxi not already registered&#10;      @grd3 capabilities_offered ⊆ CAPABILITY // set of capabilities&#10;    then&#10;      @act1 registered_taxis ≔ registered_taxis ∪ {taxi} // adds taxi to the set of registered taxi of the system&#10;      @act2 taxi_capability ≔ taxi_capability ∪  ({taxi} × capabilities_offered) // relate the taxi with the capabilities it can offer&#10;  end&#10;&#10;  event Deregister // This event removes a taxi from the system&#10;    any taxi&#10;    where&#10;      @grd1 taxi ∈ registered_taxis // taxi must be a registered one&#10;      @grd2 taxi ∉ busy_taxis // taxi must not be currently busy with delivering customer&#10;      @grd3 taxi ∉ ran(booking_taxi) // taxi is not currently booked&#10;    then&#10;      @act1 registered_taxis ≔ registered_taxis ∖ {taxi} // removes the taxi from the list of registered taxis of the system&#10;  end&#10;&#10;  event AddBooking // Create the booking to the queue received from the customer with the number of passengers, the pickup location, the destination location and priority&#10;    any booking status priority number_of_passengers customer capabilities_needed triptype&#10;    where&#10;      @grd1 booking ∈ BOOKING // booking is of type BOOKING carrier set&#10;      @grd2 booking ∉ bookings // booking does not already exist in the booking set&#10;      @grd3 booking ∉ accepted_bookings // booking does not already exist in the accepted_bookings set&#10;      @grd4 booking ∉ declined_bookings // booking does not already exist in the declined_bookings set&#10;      @grd5 booking ∉ dom(booking_number_of_passengers) // booking does not have a number of passengers relation&#10;      @grd6 booking ∉ dom(booking_taxi) // booking does not have a taxi relation&#10;      @grd7 booking ∉ dom(booking_customer) // booking does not have a customer relation&#10;      @grd8 booking ∉ dom(booking_priority) // booking does not have a priority relation&#10;      @grd9 booking ∉ dom(booking_response) // booking does not have a response relation&#10;      @grd10 booking ∉ dom(booking_status) // booking does not have a status relation&#10;      @grd11 status ∈ STATUS // status belongs to partition set STATUS&#10;      @grd12 status ∈ {open} // status belongs to partition subset {open}&#10;      @grd13 priority ∈ PRIORITY // booking does not have a priority relation&#10;      @grd14 priority ∈ {high} ∨ priority ∈ {normal} // priority set should be either high or normal&#10;      @grd15 number_of_passengers ∈ (1‥5) // range of accepted number of passengers for a taxi 1..5&#10;      @grd16 customer ∈ CUSTOMER // customer should be of type CUSTOMER&#10;      @grd17 triptype ∈ TRIP_TYPE // triptype should be of type TRIP_TYPE (to use partition in context axiom)&#10;  &#9;  @grd18 triptype ∈ {empty} // initilaising triptype by default empty as not yet set&#10;      @grd19 capabilities_needed ⊆ CAPABILITY // set of capabilities that booking needs&#10;      @grd20 registered_taxis ≠ ∅ // check that a taxi is registered within the system first (at least 1 taxi)&#10;    then&#10;      @act1 bookings ≔ bookings ∪ {booking} // Add the new booking to the bookings set&#10;      @act2 booking_number_of_passengers(booking) ≔ number_of_passengers // Add a new booking_number_of_passengers relation relating both booking and the number_of_passengers requested&#10;      @act3 booking_customer(booking) ≔ customer // Add a new booking_customer relation relating both booking and its customer&#10;      @act4 booking_priority(booking) ≔  priority // Add a new booking_priority relation relating both booking and its priority&#10;      @act5 booking_status(booking) ≔  status // Add a new booking_status relation relating both booking and its status&#10;      @act6 booking_capability ≔ booking_capability ∪ ({booking} × capabilities_needed) // relate the booking with its needed capabilities&#10;  end&#10;&#10;  event ConstructNearByTaxisPool // used to construct the pool of nearby taxis which are near to the customer&#10;  &#9;any taxi customer&#10;  &#9;where&#10;  &#9;&#9;@grd1 taxi ∈ registered_taxis // taxi must be registered&#10;  &#9;&#9;@grd2 taxi ∉ penalized_taxis // taxi must NOT be penalised&#10;  &#9;&#9;@grd3 taxi ∉ busy_taxis // taxi must NOT have a booking already&#10;  &#9;&#9;@grd4 customer ∈ CUSTOMER // type of customer&#10;  &#9;then&#10;  &#9;&#9;@act1 nearby_taxis_pool ≔ nearby_taxis_pool ∪ {taxi} // adds this taxi to the pool of taxis near the customer&#10;  end&#10;&#10;  event AddBookingtoQueue // a booking can be added to a queue of bookings&#10;  &#9;any pointer booking&#10;  &#9;where&#10;  &#9;&#9;@grd1 booking ∈ bookings // the booking should have been added&#10;  &#9;&#9;@grd2 booking ∉ accepted_bookings // the booking should not be accepted yet&#10;&#9;  &#9;@grd3 pointer ∈ ℕ1 // pointer belongs to set of positive natural numbers&#10;&#9;    @grd4 bookings_pointer ≠ ∅ ⇒ pointer &gt; max(ran(bookings_pointer)) // pointer should not be empty and holds to be less than the maximum pointer yet&#10;&#9;    @grd5 pointer ∉ ran(bookings_pointer) // pointer should not been used before&#10;&#9;    @grd6 ¬ (∃t·t ∈ registered_taxis ∧&#10;&#9;    &#9;&#9;&#9;&#9;  t ∉ ran(booking_taxi) ∧&#10;&#9;    &#9;&#9;&#9;&#9;&#9;booking_capability[{booking}] ⊆ taxi_capability[{t}])&#10;&#9;    &#9;&#9;&#9;&#9;&#9;// There is no taxi with capabilities satisfying the booking capabilities needed&#10;    then&#10;    &#9;@act1 bookings_pointer(booking) ≔ pointer // Add pointer for the queue&#10;    &#9;@act2 bookings_queue ≔ bookings_queue ∪ {booking} // Adds the booking to the queue of bookings&#10;  end&#10;&#10;  event AllocateFullTaxiBookingDirect // Allocate a taxi to a booking directly with a full response&#10;  any booking taxi response&#10;  where&#10;  &#9;@grd1 booking ∈ bookings // booking should be of type booking&#10;&#9;@grd2 taxi ∈ nearby_taxis_pool // taxi to be allocated should be a nearby one&#10;&#9;@grd3 taxi ∉ busy_taxis // taxi should not be busy&#10;&#9;@grd4 taxi ∉ penalized_taxis // taxi should not be penalized&#10;&#9;@grd5 {taxi} ∩ ran(booking_taxi) = ∅ // there is no relation between this taxi and another booking&#10;&#9;@grd6 response ∈ RESPONSE_TYPE // response should be of type RESPONSE_TYPE (to use partition in context axiom)&#10;  &#9;@grd7 response ∈ {full_response} // response should be full_response (to use partition in context axiom) to set it for the booking_response function&#10;  &#9;@grd8 booking ∉ bookings_queue // Booking should not be in the queue&#10;&#9;@grd9 ∀b·b ∈ bookings_queue ⇒&#10;&#9;&#9;&#9;&#9;¬ (booking_capability[{booking}] ⊆ taxi_capability [{taxi}])&#10;&#9;&#9;&#9;&#9;// No other booking in the queue wants the same capabilities as this booking&#10;  then&#10;  &#9;@act1 booking_taxi(booking) ≔ taxi // setting the function values to relate this booking to this taxi&#10;&#9;@act2 accepted_bookings ≔  accepted_bookings ∪ {booking} // add this booking to the accepted bookings set&#10;&#9;@act3 busy_taxis ≔ busy_taxis ∪ {taxi} // consider this taxi to be busy&#10;&#9;@act4 booking_response(booking) ≔ response // adds the response type to the function relating booking with its response&#10;  end&#10;&#10;  event AllocateFullTaxiBookingFromQueue // Allocate a taxi to a booking from the queue with a full response&#10;  any booking taxi response&#10;  where&#10;  &#9;@grd1 booking ∈ bookings_queue // booking should be in the queue&#10;&#9;@grd2 taxi ∈ nearby_taxis_pool // taxi should be one of those nearby&#10;&#9;@grd3 taxi ∉ busy_taxis // taxi shoudl not be busy&#10;&#9;@grd4 taxi ∉ penalized_taxis // taxi should not be a penalized one&#10;&#9;@grd5 {taxi} ∩ ran(booking_taxi) = ∅ // there is no relation between this taxi and another booking&#10;&#9;@grd6 response ∈ RESPONSE_TYPE // response should be of type RESPONSE_TYPE (to use partition in context axiom)&#10;  &#9;@grd7 response ∈ {full_response} // response should be full_response (to use partition in context axiom) to set it for the booking_response function&#10;  &#9;@grd8 ∀b·b ∈ bookings_queue ∧&#10;  &#9;&#9;&#9;&#9;booking_capability[{b}] ⊆ taxi_capability [{taxi}]&#10;  &#9;&#9;&#9;&#9;⇒ bookings_pointer(booking) ≤  bookings_pointer(b)&#10;  &#9;&#9;&#9;&#9;// There is another booking (b) in the queue where both need the same taxi capabilities,&#10;  &#9;&#9;&#9;&#9;// but booking is at earlier position in the queue than b&#10;  then&#10;  &#9;@act1 booking_taxi(booking) ≔ taxi // setting the function values to relate this booking to this taxi&#10;&#9;@act2 accepted_bookings ≔ accepted_bookings ∪ {booking} // add this booking to the accepted bookings set&#10;&#9;@act3 busy_taxis ≔ busy_taxis ∪ {taxi} // consider this taxi to be busy&#10;&#9;@act4 bookings_queue ≔ bookings_queue ∖ {booking} // remove this booking from the queue as it has been accepted&#10;&#9;@act5 bookings_pointer ≔ {booking} ⩤ bookings_pointer // remove the relation of the booking using domain subtraction from bookings_pointer relation&#10;&#9;@act6 booking_response(booking) ≔ response // adds the response type to the function relating booking with its response&#10;  end&#10;&#10;  event AllocateReducedTaxiBookingDirect // Allocate a taxi to a booking directly with a reduced response&#10;  any booking taxi response&#10;  where&#10;  &#9;@grd1 booking ∈ bookings // booking should be of type booking&#10;&#9;@grd2 taxi ∈ nearby_taxis_pool // taxi to be allocated should be a nearby one&#10;&#9;@grd3 taxi ∉ busy_taxis // taxi should not be busy&#10;&#9;@grd4 taxi ∉ penalized_taxis // taxi should not be penalized&#10;&#9;@grd5 {taxi} ∩ ran(booking_taxi) = ∅ // there is no relation between this taxi and another booking&#10;&#9;@grd8 response ∈ RESPONSE_TYPE // response should be of type RESPONSE_TYPE (to use partition in context axiom)&#10;&#9;@grd9 ∀b·b ∈ bookings_queue ⇒&#10;&#9;&#9;&#9;&#9;¬ (booking_capability[{booking}] ⊆ taxi_capability [{taxi}])&#10;&#9;&#9;&#9;&#9;// No other booking in the queue wants the same capabilities as this booking&#10;  &#9;@grd11 response ∈ {reduced_response}&#10;  &#9;// response should be reduced_response (to use partition in context axiom) to set it for the booking_response function&#10;  then&#10;  &#9;@act1 booking_taxi(booking) ≔ taxi // setting the function values to relate this booking to this taxi&#10;&#9;@act2 accepted_bookings ≔  accepted_bookings ∪ {booking} // add this booking to the accepted bookings set&#10;&#9;@act3 busy_taxis ≔ busy_taxis ∪ {taxi} // consider this taxi to be busy&#10;&#9;@act4 booking_response(booking) ≔ response // adds the response type to the function relating booking with its response&#10;  end&#10;&#10;  event AllocateReducedTaxiBookingFromQueue //Allocate a taxi to a booking from the queue with a reduced response&#10;  any booking taxi response&#10;  where&#10;  &#9;@grd1 booking ∈ bookings_queue //booking should be in the queue&#10;&#9;@grd2 taxi ∈ nearby_taxis_pool //taxi should be one of those nearby&#10;&#9;@grd3 taxi ∉ busy_taxis // taxi shoudl not be busy&#10;&#9;@grd4 taxi ∉ penalized_taxis // taxi should not be a penalized one&#10;&#9;@grd5 {taxi} ∩ ran(booking_taxi) = ∅ // there is no relation between this taxi and another booking&#10;&#9;@grd7 response ∈ RESPONSE_TYPE // response should be of type RESPONSE_TYPE (to use partition in context axiom)&#10;  &#9;@grd8 response ∈ {reduced_response}&#10;  &#9;// response should be reduced_response (to use partition in context axiom) to set it for the booking_response function&#10;  &#9;@grd9 ∀b·b ∈ bookings_queue ∧&#10;  &#9;&#9;&#9;&#9;booking_capability[{b}] ⊆ taxi_capability [{taxi}]&#10;  &#9;&#9;&#9;&#9;⇒ bookings_pointer(booking) ≤  bookings_pointer(b)&#10;  &#9;&#9;&#9;&#9;// There is another booking (b) in the queue where both need the same taxi capabilities,&#10;  &#9;&#9;&#9;&#9;// but booking is at earlier position in the queue than b&#10;  then&#10;  &#9;@act1 booking_taxi(booking) ≔ taxi // setting the function values to relate this booking to this taxi&#10;&#9;@act2 accepted_bookings ≔  accepted_bookings ∪ {booking} // add this booking to the accepted bookings set&#10;&#9;@act3 busy_taxis ≔ busy_taxis ∪ {taxi} // consider this taxi to be busy&#10;&#9;@act4 bookings_queue ≔ bookings_queue ∖ {booking} // remove this booking from the queue as it has been accepted&#10;&#9;@act5 bookings_pointer ≔ {booking} ⩤ bookings_pointer // remove the relation of the booking using domain subtraction from bookings_pointer relation&#10;&#9;@act6 booking_response(booking) ≔ response // adds the response type to the function relating booking with its response&#10;  end&#10;&#10;  event AcceptBookingRequest // driver accepts a booking request so the status of the booking changes from open to accept&#10;  any booking status newStatus triptype&#10;  where&#10;  &#9;@grd1 booking ∈ accepted_bookings // booking should be an accepted one&#10;  &#9;@grd2 status ∈ STATUS // status should be of type STATUS (to use partition in context axiom)&#10;  &#9;@grd3 status ∈ {open} // status belongs to partition subset {open}&#10;  &#9;@grd4 newStatus ∈ STATUS // newStatus should be of type STATUS (to use partition in context axiom)&#10;  &#9;@grd5 newStatus ∈ {accept} // newStatus belongs to partition subset {accept}&#10;  &#9;@grd6 (booking ↦ status) ∈ booking_status // a relation betwen this booking having an open status should exist&#10;  &#9;@grd7 triptype ∈ TRIP_TYPE // triptype should be of type TRIP_TYPE (to use partition in context axiom)&#10;  &#9;@grd8 triptype ∈ {empty} // triptype belongs to partition subset {empty} which was the initialisation value&#10;  then&#10;  &#9;@act1 booking_status(booking) ≔ newStatus // Changes the booking_status of this booking to its new status&#10;  &#9;@act2 bookings ≔ bookings ∖ {booking} // remove it from bookings as it is present in accepted_bookings set&#10;  end&#10;&#10;  event DriverDeclineRequest // The driver declines the booking request after accepting it&#10;  any decline_boolean booking status&#10;  where&#10;  &#9;@grd1 decline_boolean ∈ ℕ // setting a type to a numberic boolean&#10;  &#9;@grd2 decline_boolean = 0&#10;  &#9;// setting a value of the decline to be 0 as the global one driver_declined as by default he did not decline yet&#10;  &#9;@grd3 booking ∈ accepted_bookings // booking should be an accepted one&#10;  &#9;@grd4 status ∈ STATUS // status should be of type STATUS (to use partition in context axiom)&#10;  &#9;@grd5 status ∈ {accept} // status belongs to partition subset {accept}&#10;  &#9;@grd6 (booking ↦ status) ∈ booking_status //a relation betwen this booking having an accept status should exist&#10;  then&#10;  &#9;@act1 driver_declined ≔ 1 //set the driver_declined variable to 1 to indicate that the driver declined&#10;  end&#10;&#10;  event DeclineBookingRequest // adds the booking declined by the driver to the declined_bookings set&#10;&#9;  any booking status&#10;&#9;  where&#10;&#9;&#9;  @grd1 booking ∈ accepted_bookings // booking should be an accepted one&#10;&#9;&#9;  @grd2 status ∈ STATUS // status should be of type STATUS (to use partition in context axiom)&#10;&#9;&#9;  @grd3 status ∈ {decline} // status belongs to partition subset {decline}&#10;&#9;&#9;  @grd4 driver_declined = 1 //checks the driver_declined variable to check that the driver declined&#10;&#9;  then&#10;&#9;  &#9;@act1 declined_bookings ≔  declined_bookings ∪ {booking} // add this booking to the declined_bookings set&#10;  end&#10;&#10;  event PenalizeTaxi // this event penalizes the taxi according to the conditions&#10;  any booking taxi&#10;  where&#10;  &#9;@grd1 booking ∈ declined_bookings // booking was declined by the driver&#10;  &#9;@grd2 taxi ∈ busy_taxis // taxi is busy as it was allocated to this booking&#10;  &#9;@grd3 (booking ↦ taxi) ∈ booking_taxi // the relation between that booking and this taxi exists&#10;  then&#10;  &#9;@act1 penalized_taxis ≔  penalized_taxis ∪ {taxi} // taxi is added to the penalized list&#10;  &#9;@act2 busy_taxis ≔  busy_taxis ∖ {taxi} //taxi is removed from the busy taxi list&#10;  &#9;@act3 booking_taxi ≔ {booking} ⩤ booking_taxi&#10;  &#9;// this relation relating the booking to this taxi is removed by using domain subtraction using this boking&#10;  &#9;@act4 declined_bookings ≔  declined_bookings ∖ {booking} //booking is removed from the declined bookings&#10;  &#9;@act5 bookings ≔  bookings ∪ {booking} // booking is added back to the bookings to be reallocaed&#10;&#10;  end&#10;&#10;  event RemoveFromPenalised // removes the taxis from the penalized list at preference&#10;  &#9;any taxi&#10;  &#9;where&#10;  &#9;&#9;@grd1 taxi ∈ penalized_taxis // the taxi is a penalized one&#10;  &#9;then&#10;  &#9;&#9;@act1 penalized_taxis ≔ penalized_taxis ∖ {taxi}&#10;  &#9;&#9;//this taxi will be removed from the penalized list to be&#10;  &#9;&#9;//only avaiable in the registered as an available taxi ready for hire&#10;  end&#10;&#10; event AddtoWaitingList // add a customer with his pending booking to the waiting list if he requested a full response&#10; &#9;any booking customer status response&#10; &#9;where&#10;&#9;&#9;@grd1 booking ∈ accepted_bookings // booking should be accepted&#10;&#9;&#9;@grd2 customer ∈ CUSTOMER // customer have a type customer&#10;&#9;&#9;@grd3 (booking ↦ customer) ∈ booking_customer // relation relating booking to customer should exist&#10;&#9;&#9;@grd4 status ∈ STATUS // status should be of type STATUS (to use partition in context axiom)&#10;&#9;&#9;@grd5 status ∈ {pending} // status belongs to partition subset {pending}&#10;&#9;&#9;@grd6 response ∈ RESPONSE_TYPE // response should be of type RESPONSE_TYPE (to use partition in context axiom)&#10;&#9;&#9;@grd7 response ∈ {full_response}&#10;&#9;&#9;// response should be full_response (to use partition in context axiom)&#10;&#9;then&#10;&#9;&#9;@act1 waiting_list(booking) ≔ customer // adds the booking with his customer to the waiting list&#10;  end&#10;&#10;  event ChangeBookingPrioritytoHigh //changes the priority of a normal booking in the waiting list to high&#10;  &#9;any booking priority newPriority status&#10;  &#9;where&#10;  &#9;&#9;@grd1 booking ∈ accepted_bookings // booking should be accepted&#10;  &#9;&#9;@grd2 priority ∈ PRIORITY ∨ newPriority ∈ PRIORITY // priority and newPriority should be of type PRIORITY set&#10;  &#9;&#9;@grd3 priority ∈ {normal} // if the current priority of the booking is normal&#10;  &#9;&#9;@grd4 status ∈ STATUS //status should be of type status&#10;  &#9;&#9;@grd5 status ∈ {pending} // booking status is pending where it is in the waiting list&#10;  &#9;&#9;@grd6 newPriority ∈ {high} // the new priority set will be high&#10;  &#9;then&#10;  &#9;&#9;@act1 booking_priority ≔ booking_priority ∪  {booking ↦   newPriority}&#10;  end&#10;&#10;  event RemoveFromWaitingList // removes a customer with his booking from the waiting list&#10;&#9;  any booking customer status newStatus&#10;&#9;  where&#10;&#9;&#9;@grd1 booking ∈ accepted_bookings // booking should be an accepted one&#10;&#9;&#9;@grd2 customer ∈ CUSTOMER // customer have a type customer&#10;&#9;&#9;@grd3 (booking ↦ customer) ∈ waiting_list // relation stating that those pair exists in the waiting list&#10;&#9;&#9;@grd4 status ∈ STATUS ∧ newStatus ∈ STATUS //status and newStatus should be of type status&#10;&#9;&#9;@grd5 status ∈ {pending} // status should be pending as it was in the waiting list&#10;&#9;&#9;@grd6 newStatus ∈ {accept} // newStatus belongs to partition subset {accept}&#10;&#9;&#9;@grd7 (booking ↦ status) ∈ booking_status // relation relating booking with pending status should exist&#10;&#9;  then&#10;&#9;  &#9;@act1 waiting_list ≔  {booking} ⩤ waiting_list // remove from waiting list using domain subtraction by the booking&#10;&#9;  &#9;@act2 booking_status(booking) ≔  newStatus // setting the new status to the booking for booking_status relation&#10;  end&#10;&#10;  event comingToCustomer // change booking status from accept to coming&#10;  &#9;any booking statusOLD statusNEW&#10;&#9;where&#10;&#9;&#9;@grd1 booking ∈ accepted_bookings // booking should be an accepted one&#10;&#9;&#9;@grd2 booking ∉ declined_bookings // booking should not be a declined one&#10;&#9;&#9;@grd3 statusOLD ∈ STATUS ∧ statusNEW ∈ STATUS  //status and newStatus should be of type status&#10;&#9;&#9;@grd4 statusOLD ∈ {accept} // status belongs to partition subset {accept}&#10;&#9;&#9;@grd5 driver_declined = 0 // driver should not have declined&#10;&#9;&#9;@grd6 statusNEW ∈ {coming} // newStatus belongs to partition subset {coming}&#10;&#9;&#9;@grd7 (booking ↦ statusOLD) ∈ booking_status // relation relating booking with its old status should exist&#10;  &#9;then&#10;  &#9;&#9;@act1 booking_status(booking) ≔ statusNEW // assigns the newStatus to the booking&#10;  end&#10;&#10;  event pickedUpCustomer // change booking status from coming to picked&#10;   any booking statusOLD statusNEW&#10;   where&#10;&#9;  &#9;@grd1 booking ∈ accepted_bookings // booking should be an accepted one&#10;&#9;  &#9;@grd2 booking ∉ declined_bookings // booking should not be a declined one&#10;&#9;  &#9;@grd3 statusOLD ∈ STATUS ∧ statusNEW ∈ STATUS  //status and newStatus should be of type status&#10;&#9;  &#9;@grd4 statusOLD ∈ {coming} // status belongs to partition subset {comming}&#10;&#9;  &#9;@grd5 statusNEW ∈ {picked} // newStatus belongs to partition subset {picked}&#10;&#9;  &#9;@grd6 (booking ↦ statusOLD) ∈ booking_status // relation relating booking with its old status should exist&#10;   then&#10;  &#9;&#9;@act1 booking_status(booking) ≔  statusNEW // assigns the newStatus to the booking&#10;  end&#10;&#10;  event DeliveredCustomer // change booking status from picked to delivered&#10;    any booking statusOLD statusNEW&#10;&#9;where&#10;&#9;&#9;@grd1 booking ∈ accepted_bookings // booking should be an accepted one&#10;&#9;&#9;@grd2 booking ∉ declined_bookings // booking should not be a declined one&#10;&#9;&#9;@grd3 statusOLD ∈ STATUS ∧ statusNEW ∈ STATUS //status and newStatus should be of type status&#10;&#9;&#9;@grd4 statusOLD ∈ {picked} // status belongs to partition subset {picked}&#10;&#9;&#9;@grd5 statusNEW ∈ {delivered} // newStatus belongs to partition subset {delivered}&#10;&#9;&#9;@grd6 (booking ↦ statusOLD) ∈ booking_status // relation relating booking with its old status should exist&#10;&#9;then&#10;&#9;&#9;@act1 booking_status(booking) ≔  statusNEW // assigns the newStatus to the booking&#10;  end&#10;&#10;  event AlertReducedWarning // adds a reduced warning to the reduced_warnings list&#10;  &#9;any count_reduced reduce_warning response&#10;  &#9;where&#10;  &#9;&#9;@grd1 response ∈ RESPONSE_TYPE // response should be of type RESPONSE_TYPE (to use partition in context axiom)&#10;  &#9;&#9;@grd2 response ∈ {reduced_response} // response should be reduced_response (to use partition in context axiom)&#10;  &#9;&#9;@grd3 count_reduced ∈ ℕ1 //variable to hold the cardinality of type positive natural numbers&#10;  &#9;&#9;@grd4 count_reduced = card(booking_response ▷ {response}) // count all the bookings having the response reduced_response by range restriction&#10;  &#9;&#9;@grd5 count_reduced ≥ reduced_threshold // the count is greater than or equal the globally set threshold&#10;  &#9;&#9;@grd6 reduce_warning ∈ WARNING // reduce_warning should be of type WARNING&#10;&#9;then&#10;&#9;&#9;@act1 reduced_warnings ≔  reduced_warnings ∪ {reduce_warning} // alert by adding a reduced warning to the list&#10;  end&#10;&#10;  event RemoveReducedWarning // removes a reduced warning from the reduced_warnings list&#10;  &#9;any reduced_warning&#10;  &#9;where&#10;  &#9;&#9;@grd1 reduced_warning ∈ WARNING // reduce_warning should be of type WARNING&#10;  &#9;&#9;@grd2 reduced_warning ∈ reduced_warnings // reduce_warning should belong in the set of reduced warnings&#10;&#9;then&#10;&#9;&#9;@act1 reduced_warnings ≔ reduced_warnings ∖ {reduced_warning} // removes the reduced warning from the list&#10;  end&#10;&#10;  event AlertNoAllocationWarning // adds a non allocation warning to the nonallocation_warnings list&#10;&#9;any count_nonallocated nonallocated_warning status&#10;&#9;where&#10;&#9;&#9;@grd1 status ∈ STATUS // status should be of type STATUS (to use partition in context axiom)&#10;&#9;&#9;@grd2 status ∈ {open} // status belongs to partition subset {open}&#10;&#9;&#9;@grd3 count_nonallocated ∈ ℕ //variable to hold the cardinality of type positive natural numbers&#10;&#9;&#9;@grd4 count_nonallocated = card(booking_status ▷ {open}) // count all the bookings having the status open which are non allocated yet by range restriction&#10;&#9;&#9;@grd5 count_nonallocated ≥  nonallocation_threshold // the count is greater than or equal the globally set threshold&#10;&#9;&#9;@grd6 nonallocated_warning ∈ WARNING // reduce_warning should be of type WARNING&#10;&#9;then&#10;&#9;&#9;@act1 nonallocation_warnings ≔ nonallocation_warnings ∪ {nonallocated_warning} // alert by adding a nonallocation warning to the list&#10;  end&#10;&#10;  event RemoveNoAllocationWarning // removes a non allocation warning from the nonallocation_warnings list&#10;  &#9;any non_allocated_warning&#10;  &#9;where&#10;  &#9;&#9;@grd1 non_allocated_warning ∈ WARNING // non_allocated_warning should be of type WARNING&#10;  &#9;&#9;@grd2 non_allocated_warning ∈ nonallocation_warnings // non_allocated_warning should belong in the set of nonallocation warnings&#10;  &#9;then&#10;  &#9;&#9;@act1 nonallocation_warnings ≔  nonallocation_warnings ∖ {non_allocated_warning} // removes the nonallocation warning from the list&#10;  end&#10;&#10;  event RemoveBooking // After customer is delivered, booking is removed from the system and removing all its relations&#10;  &#9;any booking status taxi customer&#10;  &#9;where&#10;  &#9;&#9;@grd1 booking ∈ accepted_bookings // boooking must be an accepted one&#10;  &#9;&#9;@grd4 booking ∉ declined_bookings // booking must not be a declined one&#10;  &#9;&#9;@grd2 status ∈ STATUS // status should be of type STATUS (to use partition in context axiom)&#10;  &#9;&#9;@grd3 status ∈ {delivered} // status belongs to partition subset {delivered}&#10;  &#9;&#9;@grd5 (booking ↦ status) ∈ booking_status // relation relating booking with its status should exist&#10;  &#9;&#9;@grd6 taxi ∈ busy_taxis // taxi should be a busy one&#10;  &#9;&#9;@grd7 customer ∈ CUSTOMER // customer have a type customer&#10;  &#9;&#9;@grd8 (booking ↦ customer) ∈ booking_customer // relation relating booking with its customer should exist&#10;  &#9;&#9;@grd9 (booking ↦ taxi) ∈ booking_taxi // the relation between that booking and this taxi exists&#10;&#9;then&#10;&#9;&#9;@act1 accepted_bookings ≔ accepted_bookings ∖ {booking} // remove booking from accepted bookings&#10;&#9;&#9;@act2 booking_customer ≔ {booking} ⩤ booking_customer // remove from booking_customer using domain subtraction by the booking&#10;&#9;&#9;@act3 booking_status ≔ {booking} ⩤ booking_status // remove from booking_status using domain subtraction by the booking&#10;&#9;&#9;@act4 booking_priority ≔ {booking} ⩤ booking_priority // remove from booking_priority using domain subtraction by the booking&#10;&#9;&#9;@act5 booking_response ≔ {booking} ⩤ booking_response // remove from booking_response using domain subtraction by the booking&#10;&#9;&#9;@act6 booking_taxi ≔ {booking} ⩤ booking_taxi // remove from booking_taxi using domain subtraction by the booking&#10;&#9;&#9;@act7 booking_number_of_passengers ≔ {booking} ⩤ booking_number_of_passengers&#10;&#9;&#9; // remove from booking_number_of_passengers using domain subtraction by the booking&#10;&#9;&#9;@act8 booking_capability ≔ {booking} ⩤ booking_capability // remove from booking_capability using domain subtraction by the booking&#10;&#9;&#9;@act9 busy_taxis ≔ busy_taxis ∖ {taxi}&#10;&#9;&#9;@act10 bookings_pointer ≔  {booking} ⩤ bookings_pointer // remove from bookings_pointer using domain subtraction by the booking&#10;   end&#10;end&#10;" version="5">
<org.eventb.core.seesContext name="(" org.eventb.core.target="Taxi_Context"/>
<org.eventb.core.event name="'" org.eventb.core.comment="initialising all the set variables and thresholds to their initial values" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="INITIALISATION">
<org.eventb.core.action name="'" org.eventb.core.assignment="registered_taxis ≔ ∅" org.eventb.core.label="act1"/>
<org.eventb.core.action name="(" org.eventb.core.assignment="busy_taxis ≔ ∅" org.eventb.core.label="act2"/>
<org.eventb.core.action name=")" org.eventb.core.assignment="penalized_taxis ≔ ∅" org.eventb.core.label="act3"/>
<org.eventb.core.action name="*" org.eventb.core.assignment="bookings ≔ ∅" org.eventb.core.label="act4"/>
<org.eventb.core.action name="+" org.eventb.core.assignment="accepted_bookings ≔ ∅" org.eventb.core.label="act5"/>
<org.eventb.core.action name="," org.eventb.core.assignment="declined_bookings ≔ ∅" org.eventb.core.label="act6"/>
<org.eventb.core.action name="_3Iw0MF6ZEeOM0rIYQk1T5Q" org.eventb.core.assignment="booking_customer ≔ ∅" org.eventb.core.label="act7"/>
<org.eventb.core.action name="." org.eventb.core.assignment="booking_status ≔ ∅" org.eventb.core.label="act8"/>
<org.eventb.core.action name="/" org.eventb.core.assignment="booking_priority ≔ ∅" org.eventb.core.label="act9"/>
<org.eventb.core.action name="0" org.eventb.core.assignment="booking_response ≔  ∅" org.eventb.core.label="act10"/>
<org.eventb.core.action name="_fugREGSrEeO0z68jQ4pw7Q" org.eventb.core.assignment="booking_taxi ≔ ∅" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_3Iw0MV6ZEeOM0rIYQk1T5Q" org.eventb.core.assignment="booking_number_of_passengers ≔ ∅" org.eventb.core.label="act12"/>
<org.eventb.core.action name="_fugREWSrEeO0z68jQ4pw7Q" org.eventb.core.assignment="waiting_list ≔ ∅" org.eventb.core.label="act13"/>
<org.eventb.core.action name="_V2zO0F6aEeOM0rIYQk1T5Q" org.eventb.core.assignment="reduced_warnings ≔ ∅" org.eventb.core.label="act14"/>
<org.eventb.core.action name="_V2zO0V6aEeOM0rIYQk1T5Q" org.eventb.core.assignment="nonallocation_warnings ≔ ∅" org.eventb.core.label="act15"/>
<org.eventb.core.action name="_V2z14F6aEeOM0rIYQk1T5Q" org.eventb.core.assignment="nonallocation_threshold ≔ 5" org.eventb.core.comment="Assuming the maximum number before a non allocation warning is produced" org.eventb.core.label="act16"/>
<org.eventb.core.action name="_V2z14V6aEeOM0rIYQk1T5Q" org.eventb.core.assignment="reduced_threshold ≔ 5" org.eventb.core.comment="Assuming the maximum number before a reduced warning is produced" org.eventb.core.label="act17"/>
<org.eventb.core.action name="_V2z14l6aEeOM0rIYQk1T5Q" org.eventb.core.assignment="taxi_capability ≔ ∅" org.eventb.core.label="act18"/>
<org.eventb.core.action name="_V2z1416aEeOM0rIYQk1T5Q" org.eventb.core.assignment="booking_capability ≔ ∅" org.eventb.core.label="act19"/>
<org.eventb.core.action name="_Hnt24GHwEeOMZ_9HrMlueQ" org.eventb.core.assignment="bookings_pointer ≔ ∅" org.eventb.core.label="act20"/>
<org.eventb.core.action name="_Ro5BcGJfEeOMZ_9HrMlueQ" org.eventb.core.assignment="bookings_queue ≔  ∅" org.eventb.core.label="act21"/>
<org.eventb.core.action name="_crEBMGPaEeOMwK6AbUC7eA" org.eventb.core.assignment="driver_declined ≔ 0" org.eventb.core.comment="Assuming the the driver is willing to accept and did not decline yet by default" org.eventb.core.label="act22"/>
<org.eventb.core.action name="_fulwoGSrEeO0z68jQ4pw7Q" org.eventb.core.assignment="nearby_taxis_pool ≔ ∅" org.eventb.core.label="act23"/>
</org.eventb.core.event>
<org.eventb.core.variable name="*" org.eventb.core.comment="set containing all the taxis registered in the system" org.eventb.core.identifier="registered_taxis"/>
<org.eventb.core.variable name="," org.eventb.core.comment="set containg all the occupied (hired) taxis" org.eventb.core.identifier="busy_taxis"/>
<org.eventb.core.variable name="-" org.eventb.core.comment="set containing all the penalized taxis" org.eventb.core.identifier="penalized_taxis"/>
<org.eventb.core.variable name="." org.eventb.core.comment="set of all the booking on the system" org.eventb.core.identifier="bookings"/>
<org.eventb.core.variable name="/" org.eventb.core.comment="set of all accpeted bookings" org.eventb.core.identifier="accepted_bookings"/>
<org.eventb.core.variable name="0" org.eventb.core.comment="set of all declined bookings" org.eventb.core.identifier="declined_bookings"/>
<org.eventb.core.variable name="2" org.eventb.core.comment="a function relating a booking with its customer" org.eventb.core.identifier="booking_customer"/>
<org.eventb.core.variable name="3" org.eventb.core.comment="a function relating a booking with its status" org.eventb.core.identifier="booking_status"/>
<org.eventb.core.variable name="5" org.eventb.core.comment="a function relating a booking with its priority" org.eventb.core.identifier="booking_priority"/>
<org.eventb.core.variable name="6" org.eventb.core.comment="a function relating a booking with the response type it got" org.eventb.core.identifier="booking_response"/>
<org.eventb.core.variable name="7" org.eventb.core.comment="a function relating the bookings of the customer put on waiting list" org.eventb.core.identifier="waiting_list"/>
<org.eventb.core.variable name="9" org.eventb.core.comment="Global variable for reduced responses threshold" org.eventb.core.identifier="reduced_threshold"/>
<org.eventb.core.variable name=":" org.eventb.core.comment="Global variable for non-allocated responses threshold" org.eventb.core.identifier="nonallocation_threshold"/>
<org.eventb.core.variable name=";" org.eventb.core.comment="set of reduced responses warnings issued by the system" org.eventb.core.identifier="reduced_warnings"/>
<org.eventb.core.variable name="=" org.eventb.core.comment="set of non allocated responses warnings issued by the system" org.eventb.core.identifier="nonallocation_warnings"/>
<org.eventb.core.invariant name="A" org.eventb.core.comment="registered_taxis will be of type TAXI carrier set" org.eventb.core.label="inv1" org.eventb.core.predicate="registered_taxis ⊆ TAXI"/>
<org.eventb.core.invariant name="_UwN-EF6WEeOM0rIYQk1T5Q" org.eventb.core.comment="busy_taxis will be of type TAXI carrier set" org.eventb.core.label="inv2" org.eventb.core.predicate="busy_taxis ⊆ TAXI"/>
<org.eventb.core.invariant name="B" org.eventb.core.comment="penalized_taxis will be of type TAXI carrier set" org.eventb.core.label="inv3" org.eventb.core.predicate="penalized_taxis ⊆ TAXI"/>
<org.eventb.core.invariant name="D" org.eventb.core.comment="bookings will be of type BOOKING carrier set" org.eventb.core.label="inv4" org.eventb.core.predicate="bookings ⊆ BOOKING"/>
<org.eventb.core.invariant name="E" org.eventb.core.comment="accepted_bookings will be of type BOOKING carrier set" org.eventb.core.label="inv5" org.eventb.core.predicate="accepted_bookings ⊆ BOOKING"/>
<org.eventb.core.invariant name="F" org.eventb.core.comment="declined_bookings will be of type BOOKING carrier set" org.eventb.core.label="inv6" org.eventb.core.predicate="declined_bookings ⊆ BOOKING"/>
<org.eventb.core.invariant name="_DdKP8F6YEeOM0rIYQk1T5Q" org.eventb.core.comment="Many to one relation between a booking and its customer" org.eventb.core.label="inv7" org.eventb.core.predicate="booking_customer ∈ BOOKING ⇸ CUSTOMER"/>
<org.eventb.core.invariant name="H" org.eventb.core.comment="One to one relation between a booking and its status (open (default), coming, picked, delivered)" org.eventb.core.label="inv8" org.eventb.core.predicate="booking_status ∈ BOOKING ⤔ STATUS"/>
<org.eventb.core.invariant name="I" org.eventb.core.comment="One to one relation between a booking and its priority (high, normal)" org.eventb.core.label="inv9" org.eventb.core.predicate="booking_priority ∈ BOOKING ⤔ PRIORITY"/>
<org.eventb.core.invariant name="_UPZwgWSrEeO0z68jQ4pw7Q" org.eventb.core.comment="One to one relation between a booking and its response type (full, reduced)" org.eventb.core.label="inv30" org.eventb.core.predicate="booking_response ∈ BOOKING ⤔ RESPONSE_TYPE"/>
<org.eventb.core.invariant name="_gi8lQV6WEeOM0rIYQk1T5Q" org.eventb.core.comment="One to one relation between a booking and the taxi allocated for it" org.eventb.core.label="inv11" org.eventb.core.predicate="booking_taxi ∈ BOOKING ⤔ registered_taxis"/>
<org.eventb.core.invariant name="_UPZwgmSrEeO0z68jQ4pw7Q" org.eventb.core.comment="One to one relation between a booking and the range of number of passengers from 1 to 5" org.eventb.core.label="inv31" org.eventb.core.predicate="booking_number_of_passengers ∈ BOOKING ⤔ (1‥5)"/>
<org.eventb.core.invariant name="M" org.eventb.core.comment="Many to one relation between a booking and its customer being stored on the waiting list" org.eventb.core.label="inv13" org.eventb.core.predicate="waiting_list ∈ accepted_bookings ⇸ CUSTOMER"/>
<org.eventb.core.invariant name="N" org.eventb.core.comment="reduced responses threshold from 0..100" org.eventb.core.label="inv14" org.eventb.core.predicate="reduced_threshold ∈ (0‥100)"/>
<org.eventb.core.invariant name="O" org.eventb.core.comment="non allocated responses threshold from 0..100" org.eventb.core.label="inv15" org.eventb.core.predicate="nonallocation_threshold ∈ (0‥100)"/>
<org.eventb.core.invariant name="P" org.eventb.core.comment="reduced_warnings set of type WARNING" org.eventb.core.label="inv16" org.eventb.core.predicate="reduced_warnings ⊆ WARNING"/>
<org.eventb.core.invariant name="Q" org.eventb.core.comment="nonallocation_warnings set of type WARNING" org.eventb.core.label="inv17" org.eventb.core.predicate="nonallocation_warnings ⊆ WARNING"/>
<org.eventb.core.invariant name="R" org.eventb.core.comment="function between the taxi and its capabilities offered" org.eventb.core.label="inv18" org.eventb.core.predicate="taxi_capability ∈ registered_taxis ↔ CAPABILITY"/>
<org.eventb.core.invariant name="S" org.eventb.core.comment="function between the booking and its capabilities needed" org.eventb.core.label="inv19" org.eventb.core.predicate="booking_capability ∈ bookings ↔ CAPABILITY"/>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0ow" org.eventb.core.comment="This event registers a taxi with the system" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="RegisterTaxi">
<org.eventb.core.parameter name="_DpGPoF6XEeOM0rIYQk1T5Q" org.eventb.core.identifier="taxi"/>
<org.eventb.core.parameter name="_zMdewGJfEeOMZ_9HrMlueQ" org.eventb.core.identifier="capabilities_offered"/>
<org.eventb.core.guard name="(" org.eventb.core.comment="taxi is of type TAXI carrier set" org.eventb.core.label="grd1" org.eventb.core.predicate="taxi ∈ TAXI"/>
<org.eventb.core.guard name="*" org.eventb.core.comment="taxi not already registered" org.eventb.core.label="grd2" org.eventb.core.predicate="taxi ∉ registered_taxis"/>
<org.eventb.core.guard name="_zMeF0GJfEeOMZ_9HrMlueQ" org.eventb.core.comment="set of capabilities" org.eventb.core.label="grd3" org.eventb.core.predicate="capabilities_offered ⊆ CAPABILITY"/>
<org.eventb.core.action name=")" org.eventb.core.assignment="registered_taxis ≔ registered_taxis ∪ {taxi}" org.eventb.core.comment="adds taxi to the set of registered taxi of the system" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_PectsGJgEeOMZ_9HrMlueQ" org.eventb.core.assignment="taxi_capability ≔ taxi_capability ∪  ({taxi} × capabilities_offered)" org.eventb.core.comment="relate the taxi with the capabilities it can offer" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0ox" org.eventb.core.comment="This event removes a taxi from the system" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="Deregister">
<org.eventb.core.parameter name="_HFrEMF6XEeOM0rIYQk1T5Q" org.eventb.core.identifier="taxi"/>
<org.eventb.core.guard name="(" org.eventb.core.comment="taxi must be a registered one" org.eventb.core.label="grd1" org.eventb.core.predicate="taxi ∈ registered_taxis"/>
<org.eventb.core.guard name="_vg2vgGSrEeO0z68jQ4pw7Q" org.eventb.core.comment="taxi must not be currently busy with delivering customer" org.eventb.core.label="grd2" org.eventb.core.predicate="taxi ∉ busy_taxis"/>
<org.eventb.core.guard name="_0UHpsF6WEeOM0rIYQk1T5Q" org.eventb.core.comment="taxi is not currently booked" org.eventb.core.label="grd3" org.eventb.core.predicate="taxi ∉ ran(booking_taxi)"/>
<org.eventb.core.action name=")" org.eventb.core.assignment="registered_taxis ≔ registered_taxis ∖ {taxi}" org.eventb.core.comment="removes the taxi from the list of registered taxis of the system" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0o{" org.eventb.core.comment="Create the booking to the queue received from the customer with the number of passengers, the pickup location, the destination location and priority" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AddBooking">
<org.eventb.core.parameter name="_LBGkgF6CEeOM0rIYQk1T5Q" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name=")" org.eventb.core.identifier="status"/>
<org.eventb.core.parameter name="*" org.eventb.core.identifier="priority"/>
<org.eventb.core.parameter name="+" org.eventb.core.identifier="number_of_passengers"/>
<org.eventb.core.parameter name="_qPN-kGG9EeOSy_oee9yKOA" org.eventb.core.identifier="customer"/>
<org.eventb.core.parameter name="_da_hEGJgEeOMZ_9HrMlueQ" org.eventb.core.identifier="capabilities_needed"/>
<org.eventb.core.parameter name="_CoM4oGRQEeOMwK6AbUC7eA" org.eventb.core.identifier="triptype"/>
<org.eventb.core.guard name="_gdbjMF6CEeOM0rIYQk1T5Q" org.eventb.core.comment="booking is of type BOOKING carrier set" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ BOOKING"/>
<org.eventb.core.guard name="_gdbjMV6CEeOM0rIYQk1T5Q" org.eventb.core.comment="booking does not already exist in the booking set" org.eventb.core.label="grd2" org.eventb.core.predicate="booking ∉ bookings"/>
<org.eventb.core.guard name="." org.eventb.core.comment="booking does not already exist in the accepted_bookings set" org.eventb.core.label="grd3" org.eventb.core.predicate="booking ∉ accepted_bookings"/>
<org.eventb.core.guard name="/" org.eventb.core.comment="booking does not already exist in the declined_bookings set" org.eventb.core.label="grd4" org.eventb.core.predicate="booking ∉ declined_bookings"/>
<org.eventb.core.guard name="_3u5vAGSrEeO0z68jQ4pw7Q" org.eventb.core.comment="booking does not have a number of passengers relation" org.eventb.core.label="grd5" org.eventb.core.predicate="booking ∉ dom(booking_number_of_passengers)"/>
<org.eventb.core.guard name="1" org.eventb.core.comment="booking does not have a taxi relation" org.eventb.core.label="grd6" org.eventb.core.predicate="booking ∉ dom(booking_taxi)"/>
<org.eventb.core.guard name="2" org.eventb.core.comment="booking does not have a customer relation" org.eventb.core.label="grd7" org.eventb.core.predicate="booking ∉ dom(booking_customer)"/>
<org.eventb.core.guard name="3" org.eventb.core.comment="booking does not have a priority relation" org.eventb.core.label="grd8" org.eventb.core.predicate="booking ∉ dom(booking_priority)"/>
<org.eventb.core.guard name="4" org.eventb.core.comment="booking does not have a response relation" org.eventb.core.label="grd9" org.eventb.core.predicate="booking ∉ dom(booking_response)"/>
<org.eventb.core.guard name="5" org.eventb.core.comment="booking does not have a status relation" org.eventb.core.label="grd10" org.eventb.core.predicate="booking ∉ dom(booking_status)"/>
<org.eventb.core.guard name="6" org.eventb.core.comment="status belongs to partition set STATUS" org.eventb.core.label="grd11" org.eventb.core.predicate="status ∈ STATUS"/>
<org.eventb.core.guard name="_3u6WEGSrEeO0z68jQ4pw7Q" org.eventb.core.comment="status belongs to partition subset {open}" org.eventb.core.label="grd12" org.eventb.core.predicate="status ∈ {open}"/>
<org.eventb.core.guard name="8" org.eventb.core.comment="booking does not have a priority relation" org.eventb.core.label="grd13" org.eventb.core.predicate="priority ∈ PRIORITY"/>
<org.eventb.core.guard name="_PLO-oV6uEeOeWYtchmq-SA" org.eventb.core.comment="priority set should be either high or normal" org.eventb.core.label="grd14" org.eventb.core.predicate="priority ∈ {high} ∨ priority ∈ {normal}"/>
<org.eventb.core.guard name=":" org.eventb.core.comment="range of accepted number of passengers for a taxi 1..5" org.eventb.core.label="grd15" org.eventb.core.predicate="number_of_passengers ∈ (1‥5)"/>
<org.eventb.core.guard name=";" org.eventb.core.comment="customer should be of type CUSTOMER" org.eventb.core.label="grd16" org.eventb.core.predicate="customer ∈ CUSTOMER"/>
<org.eventb.core.guard name="_bElMAV5-EeOM0rIYQk1T5Q" org.eventb.core.comment="triptype should be of type TRIP_TYPE (to use partition in context axiom)" org.eventb.core.label="grd17" org.eventb.core.predicate="triptype ∈ TRIP_TYPE"/>
<org.eventb.core.guard name="_3u6WEWSrEeO0z68jQ4pw7Q" org.eventb.core.comment="initilaising triptype by default empty as not yet set" org.eventb.core.label="grd18" org.eventb.core.predicate="triptype ∈ {empty}"/>
<org.eventb.core.guard name="_-jMOEGG9EeOSy_oee9yKOA" org.eventb.core.comment="set of capabilities that booking needs" org.eventb.core.label="grd19" org.eventb.core.predicate="capabilities_needed ⊆ CAPABILITY"/>
<org.eventb.core.guard name="_3u69IGSrEeO0z68jQ4pw7Q" org.eventb.core.comment="check that a taxi is registered within the system first (at least 1 taxi)" org.eventb.core.label="grd20" org.eventb.core.predicate="registered_taxis ≠ ∅"/>
<org.eventb.core.action name="_NQ154F5_EeOM0rIYQk1T5Q" org.eventb.core.assignment="bookings ≔ bookings ∪ {booking}" org.eventb.core.comment="Add the new booking to the bookings set" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_7g_gkGSrEeO0z68jQ4pw7Q" org.eventb.core.assignment="booking_number_of_passengers(booking) ≔ number_of_passengers" org.eventb.core.comment="Add a new booking_number_of_passengers relation relating both booking and the number_of_passengers requested" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_NQ2g8V5_EeOM0rIYQk1T5Q" org.eventb.core.assignment="booking_customer(booking) ≔ customer" org.eventb.core.comment="Add a new booking_customer relation relating both booking and its customer" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_NQ2g8l5_EeOM0rIYQk1T5Q" org.eventb.core.assignment="booking_priority(booking) ≔  priority" org.eventb.core.comment="Add a new booking_priority relation relating both booking and its priority" org.eventb.core.label="act4"/>
<org.eventb.core.action name="_NQ2g815_EeOM0rIYQk1T5Q" org.eventb.core.assignment="booking_status(booking) ≔  status" org.eventb.core.comment="Add a new booking_status relation relating both booking and its status" org.eventb.core.label="act5"/>
<org.eventb.core.action name="_NQ2g9F5_EeOM0rIYQk1T5Q" org.eventb.core.assignment="booking_capability ≔ booking_capability ∪ ({booking} × capabilities_needed)" org.eventb.core.comment="relate the booking with its needed capabilities" org.eventb.core.label="act6"/>
</org.eventb.core.event>
<org.eventb.core.event name="_f_aOYGP8EeOMwK6AbUC7eA" org.eventb.core.comment="used to construct the pool of nearby taxis which are near to the customer" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ConstructNearByTaxisPool">
<org.eventb.core.parameter name="_f_a1cGP8EeOMwK6AbUC7eA" org.eventb.core.identifier="taxi"/>
<org.eventb.core.parameter name="_f_a1cWP8EeOMwK6AbUC7eA" org.eventb.core.identifier="customer"/>
<org.eventb.core.guard name="_f_a1cmP8EeOMwK6AbUC7eA" org.eventb.core.comment="taxi must be registered" org.eventb.core.label="grd1" org.eventb.core.predicate="taxi ∈ registered_taxis"/>
<org.eventb.core.guard name="_f_a1c2P8EeOMwK6AbUC7eA" org.eventb.core.comment="taxi must NOT be penalised" org.eventb.core.label="grd2" org.eventb.core.predicate="taxi ∉ penalized_taxis"/>
<org.eventb.core.guard name="_f_a1dGP8EeOMwK6AbUC7eA" org.eventb.core.comment="taxi must NOT have a booking already" org.eventb.core.label="grd3" org.eventb.core.predicate="taxi ∉ busy_taxis"/>
<org.eventb.core.guard name="_CZWfgGSsEeO0z68jQ4pw7Q" org.eventb.core.comment="type of customer" org.eventb.core.label="grd4" org.eventb.core.predicate="customer ∈ CUSTOMER"/>
<org.eventb.core.action name="_Jzd9wGRWEeOMwK6AbUC7eA" org.eventb.core.assignment="nearby_taxis_pool ≔ nearby_taxis_pool ∪ {taxi}" org.eventb.core.comment="adds this taxi to the pool of taxis near the customer" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_15gCwGPeEeOMwK6AbUC7eA" org.eventb.core.comment="a booking can be added to a queue of bookings" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AddBookingtoQueue">
<org.eventb.core.parameter name="_15gCwWPeEeOMwK6AbUC7eA" org.eventb.core.identifier="pointer"/>
<org.eventb.core.parameter name="_15gCwmPeEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.guard name="_3WkSEGSsEeO0z68jQ4pw7Q" org.eventb.core.comment="the booking should have been added" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ bookings"/>
<org.eventb.core.guard name="_3WkSEWSsEeO0z68jQ4pw7Q" org.eventb.core.comment="the booking should not be accepted yet" org.eventb.core.label="grd2" org.eventb.core.predicate="booking ∉ accepted_bookings"/>
<org.eventb.core.guard name="_3WkSEmSsEeO0z68jQ4pw7Q" org.eventb.core.comment="pointer belongs to set of positive natural numbers" org.eventb.core.label="grd3" org.eventb.core.predicate="pointer ∈ ℕ1"/>
<org.eventb.core.guard name="_3WkSE2SsEeO0z68jQ4pw7Q" org.eventb.core.comment="pointer should not be empty and holds to be less than the maximum pointer yet" org.eventb.core.label="grd4" org.eventb.core.predicate="bookings_pointer ≠ ∅ ⇒ pointer &gt; max(ran(bookings_pointer))"/>
<org.eventb.core.guard name="_3WkSFGSsEeO0z68jQ4pw7Q" org.eventb.core.comment="pointer should not been used before" org.eventb.core.label="grd5" org.eventb.core.predicate="pointer ∉ ran(bookings_pointer)"/>
<org.eventb.core.guard name="_3WkSFWSsEeO0z68jQ4pw7Q" org.eventb.core.comment="There is no taxi with capabilities satisfying the booking capabilities needed" org.eventb.core.label="grd6" org.eventb.core.predicate="¬ (∃t·t ∈ registered_taxis ∧&#10;&#9;    &#9;&#9;&#9;&#9;  t ∉ ran(booking_taxi) ∧&#10;&#9;    &#9;&#9;&#9;&#9;&#9;booking_capability[{booking}] ⊆ taxi_capability[{t}])"/>
<org.eventb.core.action name="_15gp02PeEeOMwK6AbUC7eA" org.eventb.core.assignment="bookings_pointer(booking) ≔ pointer" org.eventb.core.comment="Add pointer for the queue" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_Hbaz0GP_EeOMwK6AbUC7eA" org.eventb.core.assignment="bookings_queue ≔ bookings_queue ∪ {booking}" org.eventb.core.comment="Adds the booking to the queue of bookings" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_D3yQ0GQGEeOMwK6AbUC7eA" org.eventb.core.comment="Allocate a taxi to a booking directly with a full response" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AllocateFullTaxiBookingDirect">
<org.eventb.core.parameter name="_ZT27YGQHEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_ZT27YWQHEeOMwK6AbUC7eA" org.eventb.core.identifier="taxi"/>
<org.eventb.core.parameter name="_ZT27YmQHEeOMwK6AbUC7eA" org.eventb.core.identifier="response"/>
<org.eventb.core.guard name="_ZT27Y2QHEeOMwK6AbUC7eA" org.eventb.core.comment="booking should be of type booking" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ bookings"/>
<org.eventb.core.guard name="_ZT27ZGQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi to be allocated should be a nearby one" org.eventb.core.label="grd2" org.eventb.core.predicate="taxi ∈ nearby_taxis_pool"/>
<org.eventb.core.guard name="_ZT27ZWQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should not be busy" org.eventb.core.label="grd3" org.eventb.core.predicate="taxi ∉ busy_taxis"/>
<org.eventb.core.guard name="_ZT27ZmQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should not be penalized" org.eventb.core.label="grd4" org.eventb.core.predicate="taxi ∉ penalized_taxis"/>
<org.eventb.core.guard name="_ZT27Z2QHEeOMwK6AbUC7eA" org.eventb.core.comment="there is no relation between this taxi and another booking" org.eventb.core.label="grd5" org.eventb.core.predicate="{taxi} ∩ ran(booking_taxi) = ∅"/>
<org.eventb.core.guard name="_7XOrIGSsEeO0z68jQ4pw7Q" org.eventb.core.comment="response should be of type RESPONSE_TYPE (to use partition in context axiom)" org.eventb.core.label="grd6" org.eventb.core.predicate="response ∈ RESPONSE_TYPE"/>
<org.eventb.core.guard name="_D3yQ0mQGEeOMwK6AbUC7eA" org.eventb.core.comment="response should be full_response (to use partition in context axiom) to set it for the booking_response function" org.eventb.core.label="grd7" org.eventb.core.predicate="response ∈ {full_response}"/>
<org.eventb.core.guard name="_D3yQ02QGEeOMwK6AbUC7eA" org.eventb.core.comment="Booking should not be in the queue" org.eventb.core.label="grd8" org.eventb.core.predicate="booking ∉ bookings_queue"/>
<org.eventb.core.guard name="_D3y34GQGEeOMwK6AbUC7eA" org.eventb.core.comment="No other booking in the queue wants the same capabilities as this booking" org.eventb.core.label="grd9" org.eventb.core.predicate="∀b·b ∈ bookings_queue ⇒&#10;&#9;&#9;&#9;&#9;¬ (booking_capability[{booking}] ⊆ taxi_capability [{taxi}])"/>
<org.eventb.core.action name="_ZT3icGQHEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_taxi(booking) ≔ taxi" org.eventb.core.comment="setting the function values to relate this booking to this taxi" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_ZT3icWQHEeOMwK6AbUC7eA" org.eventb.core.assignment="accepted_bookings ≔  accepted_bookings ∪ {booking}" org.eventb.core.comment="add this booking to the accepted bookings set" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_ZT3icmQHEeOMwK6AbUC7eA" org.eventb.core.assignment="busy_taxis ≔ busy_taxis ∪ {taxi}" org.eventb.core.comment="consider this taxi to be busy" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_D3y34WQGEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_response(booking) ≔ response" org.eventb.core.comment="adds the response type to the function relating booking with its response" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_D3y34mQGEeOMwK6AbUC7eA" org.eventb.core.comment="Allocate a taxi to a booking from the queue with a full response" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AllocateFullTaxiBookingFromQueue">
<org.eventb.core.parameter name="_ZT3ic2QHEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_ZT3idGQHEeOMwK6AbUC7eA" org.eventb.core.identifier="taxi"/>
<org.eventb.core.parameter name="_ZT3idWQHEeOMwK6AbUC7eA" org.eventb.core.identifier="response"/>
<org.eventb.core.guard name="_ZT3idmQHEeOMwK6AbUC7eA" org.eventb.core.comment="booking should be in the queue" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ bookings_queue"/>
<org.eventb.core.guard name="_ZT3id2QHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should be one of those nearby" org.eventb.core.label="grd2" org.eventb.core.predicate="taxi ∈ nearby_taxis_pool"/>
<org.eventb.core.guard name="_ZT3ieGQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi shoudl not be busy" org.eventb.core.label="grd3" org.eventb.core.predicate="taxi ∉ busy_taxis"/>
<org.eventb.core.guard name="_ZT3ieWQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should not be a penalized one" org.eventb.core.label="grd4" org.eventb.core.predicate="taxi ∉ penalized_taxis"/>
<org.eventb.core.guard name="_ZT3iemQHEeOMwK6AbUC7eA" org.eventb.core.comment="there is no relation between this taxi and another booking" org.eventb.core.label="grd5" org.eventb.core.predicate="{taxi} ∩ ran(booking_taxi) = ∅"/>
<org.eventb.core.guard name="_D3y35GQGEeOMwK6AbUC7eA" org.eventb.core.comment="response should be of type RESPONSE_TYPE (to use partition in context axiom)" org.eventb.core.label="grd6" org.eventb.core.predicate="response ∈ RESPONSE_TYPE"/>
<org.eventb.core.guard name="_Mlo08GQKEeOMwK6AbUC7eA" org.eventb.core.comment="response should be full_response (to use partition in context axiom) to set it for the booking_response function" org.eventb.core.label="grd7" org.eventb.core.predicate="response ∈ {full_response}"/>
<org.eventb.core.guard name="_H5xigGSpEeOMwK6AbUC7eA" org.eventb.core.comment="There is another booking (b) in the queue where both need the same taxi capabilities,&#10;but booking is at earlier position in the queue than b" org.eventb.core.label="grd8" org.eventb.core.predicate="∀b·b ∈ bookings_queue ∧&#10;  &#9;&#9;&#9;&#9;booking_capability[{b}] ⊆ taxi_capability [{taxi}]&#10;  &#9;&#9;&#9;&#9;⇒ bookings_pointer(booking) ≤  bookings_pointer(b)"/>
<org.eventb.core.action name="_ZT4JgGQHEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_taxi(booking) ≔ taxi" org.eventb.core.comment="setting the function values to relate this booking to this taxi" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_ZT4JgWQHEeOMwK6AbUC7eA" org.eventb.core.assignment="accepted_bookings ≔ accepted_bookings ∪ {booking}" org.eventb.core.comment="add this booking to the accepted bookings set" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_ZT4JgmQHEeOMwK6AbUC7eA" org.eventb.core.assignment="busy_taxis ≔ busy_taxis ∪ {taxi}" org.eventb.core.comment="consider this taxi to be busy" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_MlpcAGQKEeOMwK6AbUC7eA" org.eventb.core.assignment="bookings_queue ≔ bookings_queue ∖ {booking}" org.eventb.core.comment="remove this booking from the queue as it has been accepted" org.eventb.core.label="act4"/>
<org.eventb.core.action name="_MlpcAWQKEeOMwK6AbUC7eA" org.eventb.core.assignment="bookings_pointer ≔ {booking} ⩤ bookings_pointer" org.eventb.core.comment="remove the relation of the booking using domain subtraction from bookings_pointer relation" org.eventb.core.label="act5"/>
<org.eventb.core.action name="_btdIoGQKEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_response(booking) ≔ response" org.eventb.core.comment="adds the response type to the function relating booking with its response" org.eventb.core.label="act6"/>
</org.eventb.core.event>
<org.eventb.core.event name="_D3y35WQGEeOMwK6AbUC7eA" org.eventb.core.comment="Allocate a taxi to a booking directly with a reduced response" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AllocateReducedTaxiBookingDirect">
<org.eventb.core.parameter name="_ZT4Jg2QHEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_ZT4JhGQHEeOMwK6AbUC7eA" org.eventb.core.identifier="taxi"/>
<org.eventb.core.parameter name="_ZT4JhWQHEeOMwK6AbUC7eA" org.eventb.core.identifier="response"/>
<org.eventb.core.guard name="_ZT4JhmQHEeOMwK6AbUC7eA" org.eventb.core.comment="booking should be of type booking" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ bookings"/>
<org.eventb.core.guard name="_ZT4Jh2QHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi to be allocated should be a nearby one" org.eventb.core.label="grd2" org.eventb.core.predicate="taxi ∈ nearby_taxis_pool"/>
<org.eventb.core.guard name="_ZT4JiGQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should not be busy" org.eventb.core.label="grd3" org.eventb.core.predicate="taxi ∉ busy_taxis"/>
<org.eventb.core.guard name="_ZT4JiWQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should not be penalized" org.eventb.core.label="grd4" org.eventb.core.predicate="taxi ∉ penalized_taxis"/>
<org.eventb.core.guard name="_ZT4JimQHEeOMwK6AbUC7eA" org.eventb.core.comment="there is no relation between this taxi and another booking" org.eventb.core.label="grd5" org.eventb.core.predicate="{taxi} ∩ ran(booking_taxi) = ∅"/>
<org.eventb.core.guard name="_H5ywoGSpEeOMwK6AbUC7eA" org.eventb.core.comment="response should be of type RESPONSE_TYPE (to use partition in context axiom)" org.eventb.core.label="grd8" org.eventb.core.predicate="response ∈ RESPONSE_TYPE"/>
<org.eventb.core.guard name="_CWb48WStEeO0z68jQ4pw7Q" org.eventb.core.comment="No other booking in the queue wants the same capabilities as this booking" org.eventb.core.label="grd9" org.eventb.core.predicate="∀b·b ∈ bookings_queue ⇒&#10;&#9;&#9;&#9;&#9;¬ (booking_capability[{booking}] ⊆ taxi_capability [{taxi}])"/>
<org.eventb.core.guard name="_FYAMgGStEeO0z68jQ4pw7Q" org.eventb.core.comment="response should be reduced_response (to use partition in context axiom) to set it for the booking_response function" org.eventb.core.label="grd11" org.eventb.core.predicate="response ∈ {reduced_response}"/>
<org.eventb.core.action name="_ZT4wkGQHEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_taxi(booking) ≔ taxi" org.eventb.core.comment="setting the function values to relate this booking to this taxi" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_ZT4wkWQHEeOMwK6AbUC7eA" org.eventb.core.assignment="accepted_bookings ≔  accepted_bookings ∪ {booking}" org.eventb.core.comment="add this booking to the accepted bookings set" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_ZT4wkmQHEeOMwK6AbUC7eA" org.eventb.core.assignment="busy_taxis ≔ busy_taxis ∪ {taxi}" org.eventb.core.comment="consider this taxi to be busy" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_iaLPgWTfEeOu3s7xa_4yiA" org.eventb.core.assignment="booking_response(booking) ≔ response" org.eventb.core.comment="adds the response type to the function relating booking with its response" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_D3y36GQGEeOMwK6AbUC7eA" org.eventb.core.comment="Allocate a taxi to a booking from the queue with a reduced response" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AllocateReducedTaxiBookingFromQueue">
<org.eventb.core.parameter name="_ZT4wk2QHEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_ZT4wlGQHEeOMwK6AbUC7eA" org.eventb.core.identifier="taxi"/>
<org.eventb.core.parameter name="_ZT4wlWQHEeOMwK6AbUC7eA" org.eventb.core.identifier="response"/>
<org.eventb.core.guard name="_ZT4wlmQHEeOMwK6AbUC7eA" org.eventb.core.comment="booking should be in the queue" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ bookings_queue"/>
<org.eventb.core.guard name="_ZT4wl2QHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should be one of those nearby" org.eventb.core.label="grd2" org.eventb.core.predicate="taxi ∈ nearby_taxis_pool"/>
<org.eventb.core.guard name="_ZT4wmGQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi shoudl not be busy" org.eventb.core.label="grd3" org.eventb.core.predicate="taxi ∉ busy_taxis"/>
<org.eventb.core.guard name="_ZT4wmWQHEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should not be a penalized one" org.eventb.core.label="grd4" org.eventb.core.predicate="taxi ∉ penalized_taxis"/>
<org.eventb.core.guard name="_ZT4wmmQHEeOMwK6AbUC7eA" org.eventb.core.comment="there is no relation between this taxi and another booking" org.eventb.core.label="grd5" org.eventb.core.predicate="{taxi} ∩ ran(booking_taxi) = ∅"/>
<org.eventb.core.guard name="_6gR8oGQKEeOMwK6AbUC7eA" org.eventb.core.comment="response should be of type RESPONSE_TYPE (to use partition in context axiom)" org.eventb.core.label="grd7" org.eventb.core.predicate="response ∈ RESPONSE_TYPE"/>
<org.eventb.core.guard name="_H5zXsGSpEeOMwK6AbUC7eA" org.eventb.core.comment="response should be reduced_response (to use partition in context axiom) to set it for the booking_response function" org.eventb.core.label="grd8" org.eventb.core.predicate="response ∈ {reduced_response}"/>
<org.eventb.core.guard name="_LX5SYGStEeO0z68jQ4pw7Q" org.eventb.core.comment="There is another booking (b) in the queue where both need the same taxi capabilities,&#10;but booking is at earlier position in the queue than b" org.eventb.core.label="grd9" org.eventb.core.predicate="∀b·b ∈ bookings_queue ∧&#10;  &#9;&#9;&#9;&#9;booking_capability[{b}] ⊆ taxi_capability [{taxi}]&#10;  &#9;&#9;&#9;&#9;⇒ bookings_pointer(booking) ≤  bookings_pointer(b)"/>
<org.eventb.core.action name="_ZT5XoGQHEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_taxi(booking) ≔ taxi" org.eventb.core.comment="setting the function values to relate this booking to this taxi" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_ZT5XoWQHEeOMwK6AbUC7eA" org.eventb.core.assignment="accepted_bookings ≔  accepted_bookings ∪ {booking}" org.eventb.core.comment="add this booking to the accepted bookings set" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_ZT5XomQHEeOMwK6AbUC7eA" org.eventb.core.assignment="busy_taxis ≔ busy_taxis ∪ {taxi}" org.eventb.core.comment="consider this taxi to be busy" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_6gSjsGQKEeOMwK6AbUC7eA" org.eventb.core.assignment="bookings_queue ≔ bookings_queue ∖ {booking}" org.eventb.core.comment="remove this booking from the queue as it has been accepted" org.eventb.core.label="act4"/>
<org.eventb.core.action name="_6gSjsWQKEeOMwK6AbUC7eA" org.eventb.core.assignment="bookings_pointer ≔ {booking} ⩤ bookings_pointer" org.eventb.core.comment="remove the relation of the booking using domain subtraction from bookings_pointer relation" org.eventb.core.label="act5"/>
<org.eventb.core.action name="_6gSjsmQKEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_response(booking) ≔ response" org.eventb.core.comment="adds the response type to the function relating booking with its response" org.eventb.core.label="act6"/>
</org.eventb.core.event>
<org.eventb.core.event name="_IWEgkGHCEeOMZ_9HrMlueQ" org.eventb.core.comment="driver accepts a booking request so the status of the booking changes from open to accept" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AcceptBookingRequest">
<org.eventb.core.parameter name="_SeD9gGPhEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_SeD9gWPhEeOMwK6AbUC7eA" org.eventb.core.identifier="status"/>
<org.eventb.core.parameter name="_SeD9gmPhEeOMwK6AbUC7eA" org.eventb.core.identifier="newStatus"/>
<org.eventb.core.parameter name="_k4LCkGRIEeOMwK6AbUC7eA" org.eventb.core.identifier="triptype"/>
<org.eventb.core.guard name="_SeD9g2PhEeOMwK6AbUC7eA" org.eventb.core.comment="booking should be an accepted one" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_SeD9hGPhEeOMwK6AbUC7eA" org.eventb.core.comment="status should be of type STATUS (to use partition in context axiom)" org.eventb.core.label="grd2" org.eventb.core.predicate="status ∈ STATUS"/>
<org.eventb.core.guard name="_SeD9hWPhEeOMwK6AbUC7eA" org.eventb.core.comment="status belongs to partition subset {open}" org.eventb.core.label="grd3" org.eventb.core.predicate="status ∈ {open}"/>
<org.eventb.core.guard name="_SeD9hmPhEeOMwK6AbUC7eA" org.eventb.core.comment="newStatus should be of type STATUS (to use partition in context axiom)" org.eventb.core.label="grd4" org.eventb.core.predicate="newStatus ∈ STATUS"/>
<org.eventb.core.guard name="_SeD9h2PhEeOMwK6AbUC7eA" org.eventb.core.comment="newStatus belongs to partition subset {accept}" org.eventb.core.label="grd5" org.eventb.core.predicate="newStatus ∈ {accept}"/>
<org.eventb.core.guard name="_fPtEAGPhEeOMwK6AbUC7eA" org.eventb.core.comment="a relation betwen this booking having an open status should exist" org.eventb.core.label="grd6" org.eventb.core.predicate="(booking ↦ status) ∈ booking_status"/>
<org.eventb.core.guard name="_E5XeEGQQEeOMwK6AbUC7eA" org.eventb.core.comment="triptype should be of type TRIP_TYPE (to use partition in context axiom)" org.eventb.core.label="grd7" org.eventb.core.predicate="triptype ∈ TRIP_TYPE"/>
<org.eventb.core.guard name="_k4LCkWRIEeOMwK6AbUC7eA" org.eventb.core.comment="triptype belongs to partition subset {empty} which was the initialisation value" org.eventb.core.label="grd8" org.eventb.core.predicate="triptype ∈ {empty}"/>
<org.eventb.core.action name="_aO740GPhEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_status(booking) ≔ newStatus" org.eventb.core.comment="Changes the booking_status of this booking to its new status" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_NYEaYGStEeO0z68jQ4pw7Q" org.eventb.core.assignment="bookings ≔ bookings ∖ {booking}" org.eventb.core.comment="remove it from bookings as it is present in accepted_bookings set" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_fvnh0GSfEeOMwK6AbUC7eA" org.eventb.core.comment="The driver declines the booking request after accepting it" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="DriverDeclineRequest">
<org.eventb.core.parameter name="_fvoI4GSfEeOMwK6AbUC7eA" org.eventb.core.identifier="decline_boolean"/>
<org.eventb.core.parameter name="_N0gKoGSgEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_z2R70GSkEeOMwK6AbUC7eA" org.eventb.core.identifier="status"/>
<org.eventb.core.guard name="_fvoI4WSfEeOMwK6AbUC7eA" org.eventb.core.comment="setting a type to a numberic boolean" org.eventb.core.label="grd1" org.eventb.core.predicate="decline_boolean ∈ ℕ"/>
<org.eventb.core.guard name="_fvoI4mSfEeOMwK6AbUC7eA" org.eventb.core.comment="setting a value of the decline to be 0 as the global one driver_declined as by default he did not decline yet" org.eventb.core.label="grd2" org.eventb.core.predicate="decline_boolean = 0"/>
<org.eventb.core.guard name="_N0gKoWSgEeOMwK6AbUC7eA" org.eventb.core.comment="booking should be an accepted one" org.eventb.core.label="grd3" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_z2Si4GSkEeOMwK6AbUC7eA" org.eventb.core.comment="status should be of type STATUS (to use partition in context axiom)" org.eventb.core.label="grd4" org.eventb.core.predicate="status ∈ STATUS"/>
<org.eventb.core.guard name="_z2Si4WSkEeOMwK6AbUC7eA" org.eventb.core.comment="status belongs to partition subset {accept}" org.eventb.core.label="grd5" org.eventb.core.predicate="status ∈ {accept}"/>
<org.eventb.core.guard name="_lDhcsGSlEeOMwK6AbUC7eA" org.eventb.core.comment="a relation betwen this booking having an accept status should exist" org.eventb.core.label="grd6" org.eventb.core.predicate="(booking ↦ status) ∈ booking_status"/>
<org.eventb.core.action name="_fvoI42SfEeOMwK6AbUC7eA" org.eventb.core.assignment="driver_declined ≔ 1" org.eventb.core.comment="set the driver_declined variable to 1 to indicate that the driver declined" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_IWEgkWHCEeOMZ_9HrMlueQ" org.eventb.core.comment="adds the booking declined by the driver to the declined_bookings set" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="DeclineBookingRequest">
<org.eventb.core.parameter name="_44654GPhEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_44654WPhEeOMwK6AbUC7eA" org.eventb.core.identifier="status"/>
<org.eventb.core.guard name="_44654mPhEeOMwK6AbUC7eA" org.eventb.core.comment="booking should be an accepted one" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_446542PhEeOMwK6AbUC7eA" org.eventb.core.comment="status should be of type STATUS (to use partition in context axiom)" org.eventb.core.label="grd2" org.eventb.core.predicate="status ∈ STATUS"/>
<org.eventb.core.guard name="_44655GPhEeOMwK6AbUC7eA" org.eventb.core.comment="status belongs to partition subset {decline}" org.eventb.core.label="grd3" org.eventb.core.predicate="status ∈ {decline}"/>
<org.eventb.core.guard name="_23KyoGPjEeOMwK6AbUC7eA" org.eventb.core.comment="checks the driver_declined variable to check that the driver declined" org.eventb.core.label="grd4" org.eventb.core.predicate="driver_declined = 1"/>
<org.eventb.core.action name="_DXLBcGPiEeOMwK6AbUC7eA" org.eventb.core.assignment="declined_bookings ≔  declined_bookings ∪ {booking}" org.eventb.core.comment="add this booking to the declined_bookings set" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0o}" org.eventb.core.comment="this event penalizes the taxi according to the conditions" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="PenalizeTaxi">
<org.eventb.core.parameter name="_iUjTEGP3EeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_iUj6IGP3EeOMwK6AbUC7eA" org.eventb.core.identifier="taxi"/>
<org.eventb.core.guard name="_iUj6IWP3EeOMwK6AbUC7eA" org.eventb.core.comment="booking was declined by the driver" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ declined_bookings"/>
<org.eventb.core.guard name="_iUj6ImP3EeOMwK6AbUC7eA" org.eventb.core.comment="taxi is busy as it was allocated to this booking" org.eventb.core.label="grd2" org.eventb.core.predicate="taxi ∈ busy_taxis"/>
<org.eventb.core.guard name="_iUj6I2P3EeOMwK6AbUC7eA" org.eventb.core.comment="the relation between that booking and this taxi exists" org.eventb.core.label="grd3" org.eventb.core.predicate="(booking ↦ taxi) ∈ booking_taxi"/>
<org.eventb.core.action name="_iUj6JGP3EeOMwK6AbUC7eA" org.eventb.core.assignment="penalized_taxis ≔  penalized_taxis ∪ {taxi}" org.eventb.core.comment="taxi is added to the penalized list" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_iUj6JWP3EeOMwK6AbUC7eA" org.eventb.core.assignment="busy_taxis ≔  busy_taxis ∖ {taxi}" org.eventb.core.comment="taxi is removed from the busy taxi list" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_yUeYkGSpEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_taxi ≔ {booking} ⩤ booking_taxi" org.eventb.core.comment="this relation relating the booking to this taxi is removed by using domain subtraction using this boking" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_66d-AGSpEeOMwK6AbUC7eA" org.eventb.core.assignment="declined_bookings ≔  declined_bookings ∖ {booking}" org.eventb.core.comment="booking is removed from the declined bookings" org.eventb.core.label="act4"/>
<org.eventb.core.action name="_66elEGSpEeOMwK6AbUC7eA" org.eventb.core.assignment="bookings ≔  bookings ∪ {booking}" org.eventb.core.comment="booking is added back to the bookings to be reallocaed" org.eventb.core.label="act5"/>
</org.eventb.core.event>
<org.eventb.core.event name="_akC7MGSnEeOMwK6AbUC7eA" org.eventb.core.comment="removes the taxis from the penalized list at preference" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="RemoveFromPenalised">
<org.eventb.core.parameter name="_akDiQWSnEeOMwK6AbUC7eA" org.eventb.core.identifier="taxi"/>
<org.eventb.core.guard name="_akDiQmSnEeOMwK6AbUC7eA" org.eventb.core.comment="the taxi is a penalized one" org.eventb.core.label="grd1" org.eventb.core.predicate="taxi ∈ penalized_taxis"/>
<org.eventb.core.action name="_akDiRWSnEeOMwK6AbUC7eA" org.eventb.core.assignment="penalized_taxis ≔ penalized_taxis ∖ {taxi}" org.eventb.core.comment="this taxi will be removed from the penalized list to be&#10;only avaiable in the registered as an available taxi ready for hire" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0o~" org.eventb.core.comment="add a customer with his pending booking to the waiting list if he requested a full response" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AddtoWaitingList">
<org.eventb.core.parameter name="_qQxtUGP4EeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_qQxtUWP4EeOMwK6AbUC7eA" org.eventb.core.identifier="customer"/>
<org.eventb.core.parameter name="_qQxtUmP4EeOMwK6AbUC7eA" org.eventb.core.identifier="status"/>
<org.eventb.core.parameter name="_qQxtU2P4EeOMwK6AbUC7eA" org.eventb.core.identifier="response"/>
<org.eventb.core.guard name="_qQxtVGP4EeOMwK6AbUC7eA" org.eventb.core.comment="booking should be accepted" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_qQxtVWP4EeOMwK6AbUC7eA" org.eventb.core.comment="customer have a type customer" org.eventb.core.label="grd2" org.eventb.core.predicate="customer ∈ CUSTOMER"/>
<org.eventb.core.guard name="_qQxtVmP4EeOMwK6AbUC7eA" org.eventb.core.comment="relation relating booking to customer should exist" org.eventb.core.label="grd3" org.eventb.core.predicate="(booking ↦ customer) ∈ booking_customer"/>
<org.eventb.core.guard name="_265PgGP4EeOMwK6AbUC7eA" org.eventb.core.comment="status should be of type STATUS (to use partition in context axiom)" org.eventb.core.label="grd4" org.eventb.core.predicate="status ∈ STATUS"/>
<org.eventb.core.guard name="_265PgWP4EeOMwK6AbUC7eA" org.eventb.core.comment="status belongs to partition subset {pending}" org.eventb.core.label="grd5" org.eventb.core.predicate="status ∈ {pending}"/>
<org.eventb.core.guard name="_265PgmP4EeOMwK6AbUC7eA" org.eventb.core.comment="response should be of type RESPONSE_TYPE (to use partition in context axiom)" org.eventb.core.label="grd6" org.eventb.core.predicate="response ∈ RESPONSE_TYPE"/>
<org.eventb.core.guard name="_265Pg2P4EeOMwK6AbUC7eA" org.eventb.core.comment="response should be full_response (to use partition in context axiom)" org.eventb.core.label="grd7" org.eventb.core.predicate="response ∈ {full_response}"/>
<org.eventb.core.action name="_ABfAkGP5EeOMwK6AbUC7eA" org.eventb.core.assignment="waiting_list(booking) ≔ customer" org.eventb.core.comment="adds the booking with his customer to the waiting list" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_CGDscGUiEeOu3s7xa_4yiA" org.eventb.core.comment="changes the priority of a normal booking in the waiting list to high" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ChangeBookingPrioritytoHigh">
<org.eventb.core.parameter name="_CGDscWUiEeOu3s7xa_4yiA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_CGDscmUiEeOu3s7xa_4yiA" org.eventb.core.identifier="priority"/>
<org.eventb.core.parameter name="_CGDsc2UiEeOu3s7xa_4yiA" org.eventb.core.identifier="newPriority"/>
<org.eventb.core.parameter name="_CGDsdGUiEeOu3s7xa_4yiA" org.eventb.core.identifier="status"/>
<org.eventb.core.guard name="_CGDsdWUiEeOu3s7xa_4yiA" org.eventb.core.comment="booking should be accepted" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_CGDsdmUiEeOu3s7xa_4yiA" org.eventb.core.comment="priority and newPriority should be of type PRIORITY set" org.eventb.core.label="grd2" org.eventb.core.predicate="priority ∈ PRIORITY ∨ newPriority ∈ PRIORITY"/>
<org.eventb.core.guard name="_CGDsd2UiEeOu3s7xa_4yiA" org.eventb.core.comment="if the current priority of the booking is normal" org.eventb.core.label="grd3" org.eventb.core.predicate="priority ∈ {normal}"/>
<org.eventb.core.guard name="_CGDseGUiEeOu3s7xa_4yiA" org.eventb.core.comment="status should be of type status" org.eventb.core.label="grd4" org.eventb.core.predicate="status ∈ STATUS"/>
<org.eventb.core.guard name="_CGETgGUiEeOu3s7xa_4yiA" org.eventb.core.comment="booking status is pending where it is in the waiting list" org.eventb.core.label="grd5" org.eventb.core.predicate="status ∈ {pending}"/>
<org.eventb.core.guard name="_CGETgWUiEeOu3s7xa_4yiA" org.eventb.core.comment="the new priority set will be high" org.eventb.core.label="grd6" org.eventb.core.predicate="newPriority ∈ {high}"/>
<org.eventb.core.action name="_CGETgmUiEeOu3s7xa_4yiA" org.eventb.core.assignment="booking_priority ≔ booking_priority ∪  {booking ↦   newPriority}" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0p'" org.eventb.core.comment="removes a customer with his booking from the waiting list" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="RemoveFromWaitingList">
<org.eventb.core.parameter name="_TU9cYGP5EeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_TU9cYWP5EeOMwK6AbUC7eA" org.eventb.core.identifier="customer"/>
<org.eventb.core.parameter name="_WyyOIGP5EeOMwK6AbUC7eA" org.eventb.core.identifier="status"/>
<org.eventb.core.parameter name="_g9fHkGP5EeOMwK6AbUC7eA" org.eventb.core.identifier="newStatus"/>
<org.eventb.core.guard name="_TU9cYmP5EeOMwK6AbUC7eA" org.eventb.core.comment="booking should be an accepted one" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_TU9cY2P5EeOMwK6AbUC7eA" org.eventb.core.comment="customer have a type customer" org.eventb.core.label="grd2" org.eventb.core.predicate="customer ∈ CUSTOMER"/>
<org.eventb.core.guard name="_TU9cZGP5EeOMwK6AbUC7eA" org.eventb.core.comment="relation stating that those pair exists in the waiting list" org.eventb.core.label="grd3" org.eventb.core.predicate="(booking ↦ customer) ∈ waiting_list"/>
<org.eventb.core.guard name="_g9fHkWP5EeOMwK6AbUC7eA" org.eventb.core.comment="status and newStatus should be of type status" org.eventb.core.label="grd4" org.eventb.core.predicate="status ∈ STATUS ∧ newStatus ∈ STATUS"/>
<org.eventb.core.guard name="_g9fHkmP5EeOMwK6AbUC7eA" org.eventb.core.comment="status should be pending as it was in the waiting list" org.eventb.core.label="grd5" org.eventb.core.predicate="status ∈ {pending}"/>
<org.eventb.core.guard name="_vQX-YGP5EeOMwK6AbUC7eA" org.eventb.core.comment="newStatus belongs to partition subset {accept}" org.eventb.core.label="grd6" org.eventb.core.predicate="newStatus ∈ {accept}"/>
<org.eventb.core.guard name="_H9_VgGToEeOu3s7xa_4yiA" org.eventb.core.comment="relation relating booking with pending status should exist" org.eventb.core.label="grd7" org.eventb.core.predicate="(booking ↦ status) ∈ booking_status"/>
<org.eventb.core.action name="_vQX-YWP5EeOMwK6AbUC7eA" org.eventb.core.assignment="waiting_list ≔  {booking} ⩤ waiting_list" org.eventb.core.comment="remove from waiting list using domain subtraction by the booking" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_vQX-YmP5EeOMwK6AbUC7eA" org.eventb.core.assignment="booking_status(booking) ≔  newStatus" org.eventb.core.comment="setting the new status to the booking for booking_status relation" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_iQvoEGA8EeO1XKzafDR8AA" org.eventb.core.comment="change booking status from accept to coming" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="comingToCustomer">
<org.eventb.core.parameter name="_dGYcMGBhEeO1XKzafDR8AA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_dGYcMWBhEeO1XKzafDR8AA" org.eventb.core.identifier="statusOLD"/>
<org.eventb.core.parameter name="_rgptYGBhEeO1XKzafDR8AA" org.eventb.core.identifier="statusNEW"/>
<org.eventb.core.guard name="_dGYcMmBhEeO1XKzafDR8AA" org.eventb.core.comment="booking should be an accepted one" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_dGYcM2BhEeO1XKzafDR8AA" org.eventb.core.comment="booking should not be a declined one" org.eventb.core.label="grd2" org.eventb.core.predicate="booking ∉ declined_bookings"/>
<org.eventb.core.guard name="_dGYcNGBhEeO1XKzafDR8AA" org.eventb.core.comment="status and newStatus should be of type status" org.eventb.core.label="grd3" org.eventb.core.predicate="statusOLD ∈ STATUS ∧ statusNEW ∈ STATUS"/>
<org.eventb.core.guard name="_4U_ikGBhEeO1XKzafDR8AA" org.eventb.core.comment="status belongs to partition subset {accept}" org.eventb.core.label="grd4" org.eventb.core.predicate="statusOLD ∈ {accept}"/>
<org.eventb.core.guard name="_dGYcNWBhEeO1XKzafDR8AA" org.eventb.core.comment="driver should not have declined" org.eventb.core.label="grd5" org.eventb.core.predicate="driver_declined = 0"/>
<org.eventb.core.guard name="_ysbeoWHBEeOMZ_9HrMlueQ" org.eventb.core.comment="newStatus belongs to partition subset {coming}" org.eventb.core.label="grd6" org.eventb.core.predicate="statusNEW ∈ {coming}"/>
<org.eventb.core.guard name="_YQ-28GSoEeOMwK6AbUC7eA" org.eventb.core.comment="relation relating booking with its old status should exist" org.eventb.core.label="grd7" org.eventb.core.predicate="(booking ↦ statusOLD) ∈ booking_status"/>
<org.eventb.core.action name="_rgqUcGBhEeO1XKzafDR8AA" org.eventb.core.assignment="booking_status(booking) ≔ statusNEW" org.eventb.core.comment="assigns the newStatus to the booking" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_jVSOQGA8EeO1XKzafDR8AA" org.eventb.core.comment="change booking status from coming to picked" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="pickedUpCustomer">
<org.eventb.core.parameter name="__bWhQGBhEeO1XKzafDR8AA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="__bWhQWBhEeO1XKzafDR8AA" org.eventb.core.identifier="statusOLD"/>
<org.eventb.core.parameter name="__bWhQmBhEeO1XKzafDR8AA" org.eventb.core.identifier="statusNEW"/>
<org.eventb.core.guard name="__bWhQ2BhEeO1XKzafDR8AA" org.eventb.core.comment="booking should be an accepted one" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="__bXIUGBhEeO1XKzafDR8AA" org.eventb.core.comment="booking should not be a declined one" org.eventb.core.label="grd2" org.eventb.core.predicate="booking ∉ declined_bookings"/>
<org.eventb.core.guard name="__bXIUWBhEeO1XKzafDR8AA" org.eventb.core.comment="status and newStatus should be of type status" org.eventb.core.label="grd3" org.eventb.core.predicate="statusOLD ∈ STATUS ∧ statusNEW ∈ STATUS"/>
<org.eventb.core.guard name="__bXIUmBhEeO1XKzafDR8AA" org.eventb.core.comment="status belongs to partition subset {comming}" org.eventb.core.label="grd4" org.eventb.core.predicate="statusOLD ∈ {coming}"/>
<org.eventb.core.guard name="__bXIU2BhEeO1XKzafDR8AA" org.eventb.core.comment="newStatus belongs to partition subset {picked}" org.eventb.core.label="grd5" org.eventb.core.predicate="statusNEW ∈ {picked}"/>
<org.eventb.core.guard name="_j4n-kGSfEeOMwK6AbUC7eA" org.eventb.core.comment="relation relating booking with its old status should exist" org.eventb.core.label="grd6" org.eventb.core.predicate="(booking ↦ statusOLD) ∈ booking_status"/>
<org.eventb.core.action name="__bXIVGBhEeO1XKzafDR8AA" org.eventb.core.assignment="booking_status(booking) ≔  statusNEW" org.eventb.core.comment="assigns the newStatus to the booking" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0p+" org.eventb.core.comment="change booking status from picked to delivered" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="DeliveredCustomer">
<org.eventb.core.parameter name="_FBCXYGBiEeO1XKzafDR8AA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_FBCXYWBiEeO1XKzafDR8AA" org.eventb.core.identifier="statusOLD"/>
<org.eventb.core.parameter name="_FBCXYmBiEeO1XKzafDR8AA" org.eventb.core.identifier="statusNEW"/>
<org.eventb.core.guard name="_FBCXY2BiEeO1XKzafDR8AA" org.eventb.core.comment="booking should be an accepted one" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_FBCXZGBiEeO1XKzafDR8AA" org.eventb.core.comment="booking should not be a declined one" org.eventb.core.label="grd2" org.eventb.core.predicate="booking ∉ declined_bookings"/>
<org.eventb.core.guard name="_FBCXZWBiEeO1XKzafDR8AA" org.eventb.core.comment="status and newStatus should be of type status" org.eventb.core.label="grd3" org.eventb.core.predicate="statusOLD ∈ STATUS ∧ statusNEW ∈ STATUS"/>
<org.eventb.core.guard name="_FBCXZmBiEeO1XKzafDR8AA" org.eventb.core.comment="status belongs to partition subset {picked}" org.eventb.core.label="grd4" org.eventb.core.predicate="statusOLD ∈ {picked}"/>
<org.eventb.core.guard name="_FBCXZ2BiEeO1XKzafDR8AA" org.eventb.core.comment="newStatus belongs to partition subset {delivered}" org.eventb.core.label="grd5" org.eventb.core.predicate="statusNEW ∈ {delivered}"/>
<org.eventb.core.guard name="_j4n-kWSfEeOMwK6AbUC7eA" org.eventb.core.comment="relation relating booking with its old status should exist" org.eventb.core.label="grd6" org.eventb.core.predicate="(booking ↦ statusOLD) ∈ booking_status"/>
<org.eventb.core.action name="_FBCXaGBiEeO1XKzafDR8AA" org.eventb.core.assignment="booking_status(booking) ≔  statusNEW" org.eventb.core.comment="assigns the newStatus to the booking" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0p," org.eventb.core.comment="adds a reduced warning to the reduced_warnings list" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AlertReducedWarning">
<org.eventb.core.parameter name="_nwfjkGBjEeO1XKzafDR8AA" org.eventb.core.identifier="count_reduced"/>
<org.eventb.core.parameter name="_nwfjkWBjEeO1XKzafDR8AA" org.eventb.core.identifier="reduce_warning"/>
<org.eventb.core.parameter name="_nwfjkmBjEeO1XKzafDR8AA" org.eventb.core.identifier="response"/>
<org.eventb.core.guard name="_nwfjk2BjEeO1XKzafDR8AA" org.eventb.core.comment="response should be of type RESPONSE_TYPE (to use partition in context axiom)" org.eventb.core.label="grd1" org.eventb.core.predicate="response ∈ RESPONSE_TYPE"/>
<org.eventb.core.guard name="_nwfjlGBjEeO1XKzafDR8AA" org.eventb.core.comment="response should be reduced_response (to use partition in context axiom)" org.eventb.core.label="grd2" org.eventb.core.predicate="response ∈ {reduced_response}"/>
<org.eventb.core.guard name="_nwgKoGBjEeO1XKzafDR8AA" org.eventb.core.comment="variable to hold the cardinality of type positive natural numbers" org.eventb.core.label="grd3" org.eventb.core.predicate="count_reduced ∈ ℕ1"/>
<org.eventb.core.guard name="_1ZBOwGBjEeO1XKzafDR8AA" org.eventb.core.comment="count all the bookings having the response reduced_response by range restriction" org.eventb.core.label="grd4" org.eventb.core.predicate="count_reduced = card(booking_response ▷ {response})"/>
<org.eventb.core.guard name="_une-oGBlEeO1XKzafDR8AA" org.eventb.core.comment="the count is greater than or equal the globally set threshold" org.eventb.core.label="grd5" org.eventb.core.predicate="count_reduced ≥ reduced_threshold"/>
<org.eventb.core.guard name="_IzWkEGCyEeO1XKzafDR8AA" org.eventb.core.comment="reduce_warning should be of type WARNING" org.eventb.core.label="grd6" org.eventb.core.predicate="reduce_warning ∈ WARNING"/>
<org.eventb.core.action name="_2O74MGBlEeO1XKzafDR8AA" org.eventb.core.assignment="reduced_warnings ≔  reduced_warnings ∪ {reduce_warning}" org.eventb.core.comment="alert by adding a reduced warning to the list" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0p-" org.eventb.core.comment="removes a reduced warning from the reduced_warnings list" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="RemoveReducedWarning">
<org.eventb.core.parameter name="_hqHUMGCwEeO1XKzafDR8AA" org.eventb.core.identifier="reduced_warning"/>
<org.eventb.core.guard name="_hqHUMWCwEeO1XKzafDR8AA" org.eventb.core.comment="reduce_warning should be of type WARNING" org.eventb.core.label="grd1" org.eventb.core.predicate="reduced_warning ∈ WARNING"/>
<org.eventb.core.guard name="_hqHUMmCwEeO1XKzafDR8AA" org.eventb.core.comment="reduce_warning should belong in the set of reduced warnings" org.eventb.core.label="grd2" org.eventb.core.predicate="reduced_warning ∈ reduced_warnings"/>
<org.eventb.core.action name="_hqHUM2CwEeO1XKzafDR8AA" org.eventb.core.assignment="reduced_warnings ≔ reduced_warnings ∖ {reduced_warning}" org.eventb.core.comment="removes the reduced warning from the list" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0p." org.eventb.core.comment="adds a non allocation warning to the nonallocation_warnings list" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="AlertNoAllocationWarning">
<org.eventb.core.parameter name="_IzWkEWCyEeO1XKzafDR8AA" org.eventb.core.identifier="count_nonallocated"/>
<org.eventb.core.parameter name="_IzWkEmCyEeO1XKzafDR8AA" org.eventb.core.identifier="nonallocated_warning"/>
<org.eventb.core.parameter name="_IzWkE2CyEeO1XKzafDR8AA" org.eventb.core.identifier="status"/>
<org.eventb.core.guard name="_IzWkFGCyEeO1XKzafDR8AA" org.eventb.core.comment="status should be of type STATUS (to use partition in context axiom)" org.eventb.core.label="grd1" org.eventb.core.predicate="status ∈ STATUS"/>
<org.eventb.core.guard name="_IzWkFWCyEeO1XKzafDR8AA" org.eventb.core.comment="status belongs to partition subset {open}" org.eventb.core.label="grd2" org.eventb.core.predicate="status ∈ {open}"/>
<org.eventb.core.guard name="_IzWkFmCyEeO1XKzafDR8AA" org.eventb.core.comment="variable to hold the cardinality of type positive natural numbers" org.eventb.core.label="grd3" org.eventb.core.predicate="count_nonallocated ∈ ℕ"/>
<org.eventb.core.guard name="_IzXLIGCyEeO1XKzafDR8AA" org.eventb.core.comment="count all the bookings having the status open which are non allocated yet by range restriction" org.eventb.core.label="grd4" org.eventb.core.predicate="count_nonallocated = card(booking_status ▷ {open})"/>
<org.eventb.core.guard name="_IzXLIWCyEeO1XKzafDR8AA" org.eventb.core.comment="the count is greater than or equal the globally set threshold" org.eventb.core.label="grd5" org.eventb.core.predicate="count_nonallocated ≥  nonallocation_threshold"/>
<org.eventb.core.guard name="_IzXLImCyEeO1XKzafDR8AA" org.eventb.core.comment="reduce_warning should be of type WARNING" org.eventb.core.label="grd6" org.eventb.core.predicate="nonallocated_warning ∈ WARNING"/>
<org.eventb.core.action name="_IzXLI2CyEeO1XKzafDR8AA" org.eventb.core.assignment="nonallocation_warnings ≔ nonallocation_warnings ∪ {nonallocated_warning}" org.eventb.core.comment="alert by adding a nonallocation warning to the list" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UrVNEVpvEeOf2_JL3Fy0p/" org.eventb.core.comment="removes a non allocation warning from the nonallocation_warnings list" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="RemoveNoAllocationWarning">
<org.eventb.core.parameter name="_dsrjYGCyEeO1XKzafDR8AA" org.eventb.core.identifier="non_allocated_warning"/>
<org.eventb.core.guard name="_dsrjYWCyEeO1XKzafDR8AA" org.eventb.core.comment="non_allocated_warning should be of type WARNING" org.eventb.core.label="grd1" org.eventb.core.predicate="non_allocated_warning ∈ WARNING"/>
<org.eventb.core.guard name="_ljZA8GCyEeO1XKzafDR8AA" org.eventb.core.comment="non_allocated_warning should belong in the set of nonallocation warnings" org.eventb.core.label="grd2" org.eventb.core.predicate="non_allocated_warning ∈ nonallocation_warnings"/>
<org.eventb.core.action name="_ljZA8WCyEeO1XKzafDR8AA" org.eventb.core.assignment="nonallocation_warnings ≔  nonallocation_warnings ∖ {non_allocated_warning}" org.eventb.core.comment="removes the nonallocation warning from the list" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.variable name="_UrVNEVpvEeOf2_JL3Fy0p4" org.eventb.core.comment="a function relating a booking with a taxi" org.eventb.core.identifier="booking_taxi"/>
<org.eventb.core.variable name="_UrVNEVpvEeOf2_JL3Fy0p9" org.eventb.core.comment="a function relating a booking with the number of passengers required for it" org.eventb.core.identifier="booking_number_of_passengers"/>
<org.eventb.core.event name="_RnY5EGBQEeO1XKzafDR8AA" org.eventb.core.comment="After customer is delivered, booking is removed from the system and removing all its relations" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="RemoveBooking">
<org.eventb.core.parameter name="_eKC8IGPkEeOMwK6AbUC7eA" org.eventb.core.identifier="booking"/>
<org.eventb.core.parameter name="_eKC8IWPkEeOMwK6AbUC7eA" org.eventb.core.identifier="status"/>
<org.eventb.core.parameter name="_ni9zUGPkEeOMwK6AbUC7eA" org.eventb.core.identifier="taxi"/>
<org.eventb.core.parameter name="_n5cuwGPmEeOMwK6AbUC7eA" org.eventb.core.identifier="customer"/>
<org.eventb.core.guard name="_eKC8ImPkEeOMwK6AbUC7eA" org.eventb.core.comment="boooking must be an accepted one" org.eventb.core.label="grd1" org.eventb.core.predicate="booking ∈ accepted_bookings"/>
<org.eventb.core.guard name="_hJSUcGPkEeOMwK6AbUC7eA" org.eventb.core.comment="booking must not be a declined one" org.eventb.core.label="grd4" org.eventb.core.predicate="booking ∉ declined_bookings"/>
<org.eventb.core.guard name="_eKC8I2PkEeOMwK6AbUC7eA" org.eventb.core.comment="status should be of type STATUS (to use partition in context axiom)" org.eventb.core.label="grd2" org.eventb.core.predicate="status ∈ STATUS"/>
<org.eventb.core.guard name="_eKC8JGPkEeOMwK6AbUC7eA" org.eventb.core.comment="status belongs to partition subset {delivered}" org.eventb.core.label="grd3" org.eventb.core.predicate="status ∈ {delivered}"/>
<org.eventb.core.guard name="_ni9zUWPkEeOMwK6AbUC7eA" org.eventb.core.comment="relation relating booking with its status should exist" org.eventb.core.label="grd5" org.eventb.core.predicate="(booking ↦ status) ∈ booking_status"/>
<org.eventb.core.guard name="_n5cuwWPmEeOMwK6AbUC7eA" org.eventb.core.comment="taxi should be a busy one" org.eventb.core.label="grd6" org.eventb.core.predicate="taxi ∈ busy_taxis"/>
<org.eventb.core.guard name="_9ydCYGPmEeOMwK6AbUC7eA" org.eventb.core.comment="customer have a type customer" org.eventb.core.label="grd7" org.eventb.core.predicate="customer ∈ CUSTOMER"/>
<org.eventb.core.guard name="_fok9UGStEeO0z68jQ4pw7Q" org.eventb.core.comment="relation relating booking with its customer should exist" org.eventb.core.label="grd8" org.eventb.core.predicate="(booking ↦ customer) ∈ booking_customer"/>
<org.eventb.core.guard name="_gyZtgGTsEeOu3s7xa_4yiA" org.eventb.core.comment="the relation between that booking and this taxi exists" org.eventb.core.label="grd9" org.eventb.core.predicate="(booking ↦ taxi) ∈ booking_taxi"/>
<org.eventb.core.action name="_YDlCQGPmEeOMwK6AbUC7eA" org.eventb.core.assignment="accepted_bookings ≔ accepted_bookings ∖ {booking}" org.eventb.core.comment="remove booking from accepted bookings" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_YDlCQWPmEeOMwK6AbUC7eA" org.eventb.core.assignment="booking_customer ≔ {booking} ⩤ booking_customer" org.eventb.core.comment="remove from booking_customer using domain subtraction by the booking" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_fGgUoGP1EeOMwK6AbUC7eA" org.eventb.core.assignment="booking_status ≔ {booking} ⩤ booking_status" org.eventb.core.comment="remove from booking_status using domain subtraction by the booking" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_cLVaYWStEeO0z68jQ4pw7Q" org.eventb.core.assignment="booking_priority ≔ {booking} ⩤ booking_priority" org.eventb.core.comment="remove from booking_priority using domain subtraction by the booking" org.eventb.core.label="act4"/>
<org.eventb.core.action name="_fGgUomP1EeOMwK6AbUC7eA" org.eventb.core.assignment="booking_response ≔ {booking} ⩤ booking_response" org.eventb.core.comment="remove from booking_response using domain subtraction by the booking" org.eventb.core.label="act5"/>
<org.eventb.core.action name="_fGg7sGP1EeOMwK6AbUC7eA" org.eventb.core.assignment="booking_taxi ≔ {booking} ⩤ booking_taxi" org.eventb.core.comment="remove from booking_taxi using domain subtraction by the booking" org.eventb.core.label="act6"/>
<org.eventb.core.action name="_fGg7sWP1EeOMwK6AbUC7eA" org.eventb.core.assignment="booking_number_of_passengers ≔ {booking} ⩤ booking_number_of_passengers" org.eventb.core.comment="remove from booking_number_of_passengers using domain subtraction by the booking" org.eventb.core.label="act7"/>
<org.eventb.core.action name="_fGg7smP1EeOMwK6AbUC7eA" org.eventb.core.assignment="booking_capability ≔ {booking} ⩤ booking_capability" org.eventb.core.comment="remove from booking_capability using domain subtraction by the booking" org.eventb.core.label="act8"/>
<org.eventb.core.action name="_fGg7s2P1EeOMwK6AbUC7eA" org.eventb.core.assignment="busy_taxis ≔ busy_taxis ∖ {taxi}" org.eventb.core.label="act9"/>
<org.eventb.core.action name="_ulLCEGP1EeOMwK6AbUC7eA" org.eventb.core.assignment="bookings_pointer ≔  {booking} ⩤ bookings_pointer" org.eventb.core.comment="remove from bookings_pointer using domain subtraction by the booking" org.eventb.core.label="act10"/>
</org.eventb.core.event>
<org.eventb.core.variable name="_2xwGgGHHEeOMZ_9HrMlueQ" org.eventb.core.comment="function between a taxi and capabilities offered" org.eventb.core.identifier="taxi_capability"/>
<org.eventb.core.invariant name="_2xwGgWHHEeOMZ_9HrMlueQ" org.eventb.core.comment="nearby taxis must be registered with the system" org.eventb.core.label="inv20" org.eventb.core.predicate="nearby_taxis_pool ⊆ registered_taxis"/>
<org.eventb.core.variable name="_RpAWMGJfEeOMZ_9HrMlueQ" org.eventb.core.comment="function between a booking and capabilities needed" org.eventb.core.identifier="booking_capability"/>
<org.eventb.core.invariant name="_RpAWMWJfEeOMZ_9HrMlueQ" org.eventb.core.comment="bookings in the queue must have BOOKING type" org.eventb.core.label="inv21" org.eventb.core.predicate="bookings_queue ⊆ bookings"/>
<org.eventb.core.variable name="_08KKkGP7EeOMwK6AbUC7eA" org.eventb.core.comment="Set of taxis nearby the customer" org.eventb.core.identifier="nearby_taxis_pool"/>
<org.eventb.core.variable name="_fsFX0GP-EeOMwK6AbUC7eA" org.eventb.core.comment="Queue for the bookings" org.eventb.core.identifier="bookings_queue"/>
<org.eventb.core.variable name="_VYLCYGPaEeOMwK6AbUC7eA" org.eventb.core.comment="Pointer for the bookings queue" org.eventb.core.identifier="bookings_pointer"/>
<org.eventb.core.invariant name="_TUsSQGPbEeOMwK6AbUC7eA" org.eventb.core.comment="relating the pointer of the booking queue to have range of positive numbers" org.eventb.core.label="inv22" org.eventb.core.predicate="bookings_pointer ∈ bookings_queue ↣ ℕ1"/>
<org.eventb.core.invariant name="_j4dmkGPbEeOMwK6AbUC7eA" org.eventb.core.comment="finite constraint to use the max function must have a known size" org.eventb.core.label="inv23" org.eventb.core.predicate="finite(ran(bookings_pointer))"/>
<org.eventb.core.invariant name="_iorgEWPjEeOMwK6AbUC7eA" org.eventb.core.comment="finite constraint to use the card function must have a known size" org.eventb.core.label="inv24" org.eventb.core.predicate="finite(booking_response)"/>
<org.eventb.core.invariant name="_08KKkWP7EeOMwK6AbUC7eA" org.eventb.core.comment="Boolean value to check if the driver has declined 0=NO &amp; 1=YES" org.eventb.core.label="inv25" org.eventb.core.predicate="driver_declined ∈ ℕ"/>
<org.eventb.core.variable name="_iorgEGPjEeOMwK6AbUC7eA" org.eventb.core.comment="boolean variable to check if the driver has declined or not" org.eventb.core.identifier="driver_declined"/>
</org.eventb.core.machineFile>
